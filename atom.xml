<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyHive&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://SkyHive.github.io/"/>
  <updated>2018-04-20T05:30:17.681Z</updated>
  <id>http://SkyHive.github.io/</id>
  
  <author>
    <name>SkyHive</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Ubuntu循环登录界面</title>
    <link href="http://SkyHive.github.io/2018/04/20/%E5%85%B3%E4%BA%8EUbuntu%E5%BE%AA%E7%8E%AF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2/"/>
    <id>http://SkyHive.github.io/2018/04/20/关于Ubuntu循环登录界面/</id>
    <published>2018-04-20T04:36:21.000Z</published>
    <updated>2018-04-20T05:30:17.681Z</updated>
    
    <content type="html"><![CDATA[<p>其实事情的起因很奇怪，前两天一直想升级Ubuntu 18.04，不知道为什么17.10用着怪怪的，但是18.04又要到4月26号才发布，没有办法了只能Beta 2先用着试试了。</p><p>然后就是一顿正常的操作</p><a id="more"></a><h4 id="从Ubuntu-17-10-升级到-18-04-Beta-2"><a href="#从Ubuntu-17-10-升级到-18-04-Beta-2" class="headerlink" title="从Ubuntu 17.10 升级到 18.04 Beta 2"></a>从Ubuntu 17.10 升级到 18.04 Beta 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 先将当前系统更新</div><div class="line">sudo apt update</div><div class="line">sudo apt upgrade</div><div class="line">#然后升级系统</div><div class="line">sudo do-release-upgrade -d</div></pre></td></tr></table></figure><p>然后就让系统自己去下载安装了，不过中途我在终端提示中看到了某个什么东西不可用，当然我也没有在意，估计更新到了正式版系统就没事了吧，结果这就埋下了伏笔。</p><h4 id="卡在了启动界面"><a href="#卡在了启动界面" class="headerlink" title="卡在了启动界面"></a>卡在了启动界面</h4><p>没错，就是那个带着Ubuntu logo，然后logo下面还有几个小点点的那个界面，卡的死死的。ESC之后显示的状态应该是这样的</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[Started]</span> Gnome <span class="attribute">Display</span> Manage</div></pre></td></tr></table></figure><p>然后我当机立断的去Google了一下，不知道在哪里看到了一个答案是要进Recovery mode修复一下dpkg，做完之后我觉得这并不够，开在启动界面的事情我第一次装Ubuntu也是遇到过，我知道是显卡驱动的问题，然后不知道在哪看到的方法，把我Nvidia驱动给卸载掉了。</p><blockquote><p>第一次装Ubuntu遇到这问题，解决的办法是在Ubuntu 高级选项中，对需要引导的内核按e进行编辑，在 <code>quiet splash</code>那一行后面加上<code>acpi_osi=linux nomodeset</code>，这个是针对N卡的，如果是A卡或者Intel核显有对应的解决办法</p></blockquote><h4 id="Ubuntu-Login-Loop"><a href="#Ubuntu-Login-Loop" class="headerlink" title="Ubuntu Login Loop"></a>Ubuntu Login Loop</h4><p>重启之后确实能度过了logo的那一关，但是新的问题又来了，这次能达到登录的界面，但是输入密码登录之后会黑屏一下又回到登录界面。</p><p>这个<code>Ubuntu Login Loop</code>的问题已经不新鲜了，之前每个版本都有人遇到过，而且引起的原因也各不相同，这次我遇到了这个坑就来稍微的总结一下</p><ul><li><p><code>.Xauthority</code>文件的所有人和所有组变成了root：在你用户的主目录下有一个<code>.Xauthority</code>文件，用<code>ls -la</code>查看一下该文件的所有人和所有组，如果是root的话那么需要将其改为你的登录用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown username:username .Xauthority</div></pre></td></tr></table></figure></li><li><p><code>/tmp</code>权限：用<code>ls -ld</code>查看一下<code>/tmp</code>的权限是否是<code>drwxrwxrwxt</code>，否则就将其权限修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod a+wt /tmp</div></pre></td></tr></table></figure></li><li><p>当然还有就是显卡驱动惹的祸：网上大部分人都是更新了显卡驱动才一直循环登录界面，而我就比较特殊了，我是卸载了显卡驱动，不过解决办法都是一样，就是重装显卡驱动呗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#完全卸载N卡驱动</div><div class="line">sudo apt remove --purge nvidia*</div><div class="line">#关闭图形界面</div><div class="line">sudo service lightdm stop</div><div class="line">#禁用nouveau驱动</div><div class="line">#在/etc/modprobe.d/blacklist.conf中加入如下内容：</div><div class="line">blacklist nouveau</div><div class="line">options nouveau modeset=0</div><div class="line">#然后执行</div><div class="line">sudo update-initramfs -u</div><div class="line">#安装Nvidia驱动</div><div class="line">sudo add-apt-repository ppa:xorg-edgers/ppa #添加ppa源</div><div class="line">sudo add-apt-repository ppa:graphics-drivers/ppa #添加ppa源</div><div class="line">sudo apt update #更新apt-get</div><div class="line">sudo apt install nvidia-375</div><div class="line">#最后别忘了打开图形化界面</div><div class="line">sudo service lightdm start</div></pre></td></tr></table></figure><p>由于我的显卡是GTX 960M，参考了一下网友们安装的是375的显卡驱动，等我安装完成后，系统提醒我显卡驱动太低级需要升级，没有办法还是升到了390，然后重启一下，输入密码又回到了熟悉的图形化界面</p></li></ul><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>当然login loop的原因不止这些，有时候<code>/etc/profile</code>中改了或者加了些东西导致这些古怪的问题，所以我们需要对症下药。正确的做法是要先去查看主目录下<code>.xsession-errors</code>日志的报错信息，从而去判断原因。</p><p>什么？你问我图形化界面进不去怎么做那么多操作？图形化进不去，还有命令行啊，我的图形化是tty1，以上操作都是在tty5中进行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实事情的起因很奇怪，前两天一直想升级Ubuntu 18.04，不知道为什么17.10用着怪怪的，但是18.04又要到4月26号才发布，没有办法了只能Beta 2先用着试试了。&lt;/p&gt;
&lt;p&gt;然后就是一顿正常的操作&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>初探Django需要注意的事项</title>
    <link href="http://SkyHive.github.io/2018/03/25/%E5%88%9D%E6%8E%A2Django%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9/"/>
    <id>http://SkyHive.github.io/2018/03/25/初探Django需要注意的事项/</id>
    <published>2018-03-25T12:55:33.000Z</published>
    <updated>2018-03-25T12:59:51.987Z</updated>
    
    <content type="html"><![CDATA[<h4 id="更改默认数据库为MySQL"><a href="#更改默认数据库为MySQL" class="headerlink" title="更改默认数据库为MySQL"></a>更改默认数据库为MySQL</h4><p>Django使用的默认数据库是SQLite3，如果习惯使用的是SQLite的用户就可以不必更换数据库。</p><p>更换数据库的话在<code>settings.py</code>文件中<code>DATABASES</code>选项中进行更改<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DATABASES = &#123;</div><div class="line">    <span class="string">'default'</span>: &#123;</div><div class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</div><div class="line">        <span class="string">'NAME'</span>: <span class="string">'项目对应的数据库名称'</span>,</div><div class="line">        <span class="string">'USER'</span>: <span class="string">'登录mysql的帐户'</span>,</div><div class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'登录mysql的密码'</span>,</div><div class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,<span class="comment">#由于是在本地开发，所以是127.0.0.1</span></div><div class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span><span class="comment">#这里mysql使用的是默认的3306端口</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="设置Templates的路径"><a href="#设置Templates的路径" class="headerlink" title="设置Templates的路径"></a>设置Templates的路径</h4><p>在<code>settings.py</code>文件中的<code>TEMPLATES</code>选项中进行设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)]</div></pre></td></tr></table></figure><p>其中<code>BASE_DIR</code>是项目的绝对路径，设置过<code>Templates</code>路径之后<code>Django</code>会在改路径下的<code>templates</code>文件夹下搜索对应的<code>html</code>文件。</p><h4 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h4><p><code>settings.py</code>最后有个选项为<code>LANGUAGE_CODE</code>，这个选项是设置<code>Django</code>语言的。<code>Django</code>为我们提供了很多自带的应用，如果习惯了看英文的话可以不用设置，直接使用默认的英语，如果英语看着膈应的话，可以设置为中文<code>zh-hans</code>或者<code>zh_Hans</code></p><h4 id="添加创建的应用"><a href="#添加创建的应用" class="headerlink" title="添加创建的应用"></a>添加创建的应用</h4><p>当你新建应用之后要记得在<code>settings.py</code>中的<code>INSTALLED_APPS</code>选项中添加新建的应用——直接在最后一行添加新建的应用名就好了。</p><h4 id="修改数据默认显示名称"><a href="#修改数据默认显示名称" class="headerlink" title="修改数据默认显示名称"></a>修改数据默认显示名称</h4><p>在创建的数据类下面添加一个方法，根据Python的版本进行选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python <span class="number">2.7</span> : __unicode__(self)</div><div class="line">python <span class="number">3</span> : __str__(self)</div><div class="line">然后在方法中返回self.var<span class="comment">#var是类中数据中用来显示数据的变量</span></div></pre></td></tr></table></figure><h4 id="Tamplates-过滤器"><a href="#Tamplates-过滤器" class="headerlink" title="Tamplates 过滤器"></a>Tamplates 过滤器</h4><p>这个过滤器其实可以说就是Linux下的管道符<code>|</code>，Linux玩的转的人对这个一定不会陌生，过滤器的基本形式就像这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;var | filter&#125;&#125;</div></pre></td></tr></table></figure><p>有些过滤器会跟有参数，过滤器的参数都是跟随冒号，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;var | default:<span class="string">'0'</span>&#125;&#125;<span class="comment">#为变量var设置默认值0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;更改默认数据库为MySQL&quot;&gt;&lt;a href=&quot;#更改默认数据库为MySQL&quot; class=&quot;headerlink&quot; title=&quot;更改默认数据库为MySQL&quot;&gt;&lt;/a&gt;更改默认数据库为MySQL&lt;/h4&gt;&lt;p&gt;Django使用的默认数据库是SQLite3，如果习惯使用的是SQLite的用户就可以不必更换数据库。&lt;/p&gt;
&lt;p&gt;更换数据库的话在&lt;code&gt;settings.py&lt;/code&gt;文件中&lt;code&gt;DATABASES&lt;/code&gt;选项中进行更改&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://SkyHive.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>配置ssh免密登录遇到的坑</title>
    <link href="http://SkyHive.github.io/2017/12/08/%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://SkyHive.github.io/2017/12/08/配置ssh免密登录遇到的坑/</id>
    <published>2017-12-08T03:12:43.000Z</published>
    <updated>2017-12-08T03:14:20.525Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学校做一个云计算大赛，需要搭建一个hadoop的平台（一共四台服务器，这是一个怎样的hadoop啊），搭建的中途遇到一个小插曲。<br>由于需要四台服务器能够互相免密访问，我们需要将四台服务器的公钥互相上传到各个机器，首先运行<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ssh-keygen -t rsa</span></div></pre></td></tr></table></figure></p><a id="more"></a><p>然后一直回车，最后会在你主目录下生成一个<code>.ssh</code>目录，其中的<code>id_rsa</code>是你的密钥，<code>id_rsa.pub</code>是你要上传的公钥，<code>known_hosts</code>是你连接过的主机的信息<br><img src="http://old5ws7lp.bkt.clouddn.com/images/ssh.png"></p><p>我们需要在<code>.ssh</code>目录下建立一个<code>authorized_keys</code>文件，将各个主机的公钥信息存储在该文件下，然后各个主机就可以通过ssh免密登录了，至于具体的原理，大家可以网上自行科普一下，无非是一些加密解密的过程。</p><p>然而就在我以为万无一失的时候，造化弄人，我不管怎么搞都需要输密码，试过改ssh的配置文件也无法解决，最后google到一个解决方法，说是目录的和文件的权限问题，<code>.ssh</code>目录的权限必须得是<strong>700</strong>，而文件<code>authorized_keys</code>的权限必须是<strong>644</strong>，而我当时是664,这才导致无法进行免密登录，这里大家需要注意一下权限的问题，即使权限放大了也是不行的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学校做一个云计算大赛，需要搭建一个hadoop的平台（一共四台服务器，这是一个怎样的hadoop啊），搭建的中途遇到一个小插曲。&lt;br&gt;由于需要四台服务器能够互相免密访问，我们需要将四台服务器的公钥互相上传到各个机器，首先运行&lt;br&gt;&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;ssh-keygen -t rsa&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hadoop简介</title>
    <link href="http://SkyHive.github.io/2017/11/17/Hadoop%E7%AE%80%E4%BB%8B/"/>
    <id>http://SkyHive.github.io/2017/11/17/Hadoop简介/</id>
    <published>2017-11-17T12:56:31.000Z</published>
    <updated>2017-11-22T13:38:37.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hadoop-介绍"><a href="#Hadoop-介绍" class="headerlink" title="Hadoop 介绍"></a>Hadoop 介绍</h3><p>Hadoop是Apache组织的一个分布式计算框架（java语言），其最核心的设计就是：<strong>HDFS</strong> 和<strong>MapReduce</strong>，HDFS实现存储，MapReduce实现原理分析处理。</p><h4 id="HDFS文件系统"><a href="#HDFS文件系统" class="headerlink" title="HDFS文件系统"></a>HDFS文件系统</h4><p><strong>HDFS</strong>（Hadoop Distributed File System）是一个高度容错的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合那些有着超大数据集的应用程序。<br><a id="more"></a></p><h5 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h5><ul><li>大数据文件，适合大文件或者一堆大数据文件</li><li>文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算机上</li><li>流式数据访问，一次写入多次读写，和传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化只能在文件末尾添加</li><li>廉价硬件</li><li>备份，为防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其他某几个主机上</li></ul><h5 id="Master-Slave架构"><a href="#Master-Slave架构" class="headerlink" title="Master / Slave架构"></a>Master / Slave架构</h5><p>一个HDFS集群是有一个Namenode和一定数目的Datanode组成。Namenode作为中心服务器负责管理文件系统的namespace和客户端对文件的访问，Datanode在集群中负责管理结点上他们附带的存储。在内部，一个文件其实分成一个或多个block，这些block存储在Datanode集合里。Namenode执行文件系统的namespace操作，如打开、关闭、重命名等，同时决定 block到具体Datanode结点的映射。Datanode在Namenode的指挥下进行block的创建、删除和复制。</p><h5 id="HDFS的一些关键元素"><a href="#HDFS的一些关键元素" class="headerlink" title="HDFS的一些关键元素"></a>HDFS的一些关键元素</h5><ul><li>Block：将文件分块，通常为64M。</li><li>NameNode：保存整个文件系统的目录信息、文件信息及分块信息，由唯一一台主机专门保存。（2.0版本后增加备份）</li><li>DataNode：用于存储Block文件。</li><li>NameNode全权管理数据块的复制，它周期性地从集群中的每个DataNode接受心跳信号和块状态报告（BlockReport）。结合艘到心跳信号以为这该DataNode工作正常，块状态报告包含了一个该DataNode上所有数据块的列表。</li></ul><h4 id="MapReduce文件系统"><a href="#MapReduce文件系统" class="headerlink" title="MapReduce文件系统"></a>MapReduce文件系统</h4><p>MapReduce是一种编程模型，用于大规模数据的并行运算。MapReduce分成两个部分：<strong>Map</strong>（映射）和<strong>Reduce</strong>（归纳）。当你向MapReduce框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map任务，然后分配到不同的节点上去执行，每一个Map任务处理输入数据中的一部分，当Map任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce任务的输入数据。Reduce任务的主要目标就是把前面若干个Map的输出汇总并输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hadoop-介绍&quot;&gt;&lt;a href=&quot;#Hadoop-介绍&quot; class=&quot;headerlink&quot; title=&quot;Hadoop 介绍&quot;&gt;&lt;/a&gt;Hadoop 介绍&lt;/h3&gt;&lt;p&gt;Hadoop是Apache组织的一个分布式计算框架（java语言），其最核心的设计就是：&lt;strong&gt;HDFS&lt;/strong&gt; 和&lt;strong&gt;MapReduce&lt;/strong&gt;，HDFS实现存储，MapReduce实现原理分析处理。&lt;/p&gt;
&lt;h4 id=&quot;HDFS文件系统&quot;&gt;&lt;a href=&quot;#HDFS文件系统&quot; class=&quot;headerlink&quot; title=&quot;HDFS文件系统&quot;&gt;&lt;/a&gt;HDFS文件系统&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;（Hadoop Distributed File System）是一个高度容错的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合那些有着超大数据集的应用程序。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://SkyHive.github.io/2017/10/15/%E9%98%9F%E5%88%97/"/>
    <id>http://SkyHive.github.io/2017/10/15/队列/</id>
    <published>2017-10-15T02:57:44.000Z</published>
    <updated>2017-10-15T03:02:05.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种可以实现<strong>先进先出</strong>(first in first out,FIFO)的存储结构。与栈不一样的是，队列规定只在一端进行插入操作，在另一端进行删除操作。允许插入的一端叫做队尾(rear)，允许删除的一端叫做队首(front)。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>链式队列：用链表实现。</li><li>静态队列：用数组实现。(<em>为了解决假溢出现象，静态队列通常都必须是循环队列</em>)</li></ul><a id="more"></a><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><img src="http://old5ws7lp.bkt.clouddn.com/images/Queue.jpg"><h5 id="参数：front、rear"><a href="#参数：front、rear" class="headerlink" title="参数：front、rear"></a>参数：front、rear</h5><ul><li>rear所指的单元始终为空</li><li>队列初始化：front和rear的值都是0。</li><li>队列非空：front指向队列的第一个元素；rear指向队列的最后一个有效元素的下一个元素。</li><li>队列空：front和rear值相等，但不一定是0。</li></ul><h5 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h5><p>1.入队：将值存入rear所代表的位置<code>r</code></p><ul><li>错误写法：<code>r=r+1</code></li><li>正确写法：<code>r=(r+1)%数组长度</code></li></ul><p>2.出队：<br><code>f=(f+1)%数组长度</code></p><p>3.判断循环队列是否为空</p><p><code>rear = front</code></p><p>4.判断循环队列是否已满</p><ul><li>多增加一个参数标志满或者空（一般不用此方式）</li><li>少用一个元素：如果<code>(r+1)%数组长度==f</code>表示循环队列已满</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>1.队列数据建构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">queue</span> &#123;</div><div class="line">  <span class="keyword">int</span> *p;</div><div class="line">  <span class="keyword">int</span> front;</div><div class="line">  <span class="keyword">int</span> rear;</div><div class="line">  <span class="keyword">int</span> maxsize;</div><div class="line">&#125;Queue;</div></pre></td></tr></table></figure><p>2.初始化队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateQueue</span><span class="params">(Queue *Q,<span class="keyword">int</span> maxsize)</span></span>&#123;</div><div class="line">  Q-&gt;p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*maxsize);</div><div class="line">  <span class="keyword">if</span>(!Q-&gt;p)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failure!"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line">  Q-&gt;front = Q-&gt;rear;</div><div class="line">  Q-&gt;maxize = maxsize;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3.判断循环队列是否为满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(Queue *Q)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%Q-&gt;maxsize == Q-&gt;front)</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.判断循环队列是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Queue *Q)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.入队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enter</span><span class="params">(Queue *Q,<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (isFull(Q))&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The queue is full!"</span>);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">  Q-&gt;p[Q-&gt;rear] = val;</div><div class="line">      Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%Q-&gt;maxsize;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>6.出队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Queue *Q,<span class="keyword">int</span> *val)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(isEmpty(Q))</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">  *val = Q-&gt;p[Q-&gt;front];</div><div class="line">      Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%Q-&gt;maxszie;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Get out of the queue successfully!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>7.遍历操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Queue *Q)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> i = Q-&gt;front;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The items in queue are:\n"</span>);</div><div class="line">  <span class="keyword">while</span>(i%Q-&gt;maxsize!=Q-&gt;rear)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,Q-&gt;p[i]);</div><div class="line">      i=(i+<span class="number">1</span>)%Q-&gt;maxsize;</div><div class="line">&#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p>链式队列实现和链式栈相差不多，只是将删除操作放在了另外一端，有效的解决了顺序队列存储空间不足的缺陷。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>1.队列节点构建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node&#123;</div><div class="line">  <span class="keyword">int</span> data;<span class="comment">//数据域</span></div><div class="line">  <span class="keyword">struct</span> Node *next;<span class="comment">//指针域</span></div><div class="line">&#125;Node;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">  Node *front;</div><div class="line">  Node *rear;</div><div class="line">&#125;Queue;</div></pre></td></tr></table></figure><p>2.队列初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(Queue *Q)</span></span>&#123;</div><div class="line">  Node *head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">  <span class="keyword">if</span>(!head)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!\n"</span>);</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line">  head-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  Q-&gt;rear = Q-&gt;front = head;<span class="comment">//front和rear都指向头指针</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Init successfully!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3.入队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Enter</span><span class="params">(Queue *Q,<span class="keyword">int</span> item)</span></span>&#123;</div><div class="line">  Node *s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">  <span class="keyword">if</span>(!s)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!\n"</span>);</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line">  s-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  s-&gt;data = item;</div><div class="line">  Q-&gt;rear-&gt;next = s;</div><div class="line">  Q-&gt;rear = s;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.出队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Queue *Q,<span class="keyword">int</span> *item)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The queue is empty!\n"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">  Node *p;</div><div class="line">  p = Q-&gt;front-&gt;next;<span class="comment">//先将要出栈的节点存在P中</span></div><div class="line">  Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//重新构造队头元素的后继</span></div><div class="line">  *item = p-&gt;data;<span class="comment">//保存出队的数据；</span></div><div class="line">  <span class="keyword">if</span>(Q-&gt;rear == p)<span class="comment">//判断删除的节点是否为队尾元素</span></div><div class="line">      Q-&gt;rear = Q-&gt;front;</div><div class="line">  <span class="built_in">free</span>(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.遍历元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Queue *Q)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The queue is empty!\n"</span>);</div><div class="line">&#125;</div><div class="line">  Node *p = Q-&gt;front-&gt;next;</div><div class="line">  <span class="keyword">while</span>(p)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</div><div class="line">      p = p-&gt;next;</div><div class="line">&#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;队列是一种可以实现&lt;strong&gt;先进先出&lt;/strong&gt;(first in first out,FIFO)的存储结构。与栈不一样的是，队列规定只在一端进行插入操作，在另一端进行删除操作。允许插入的一端叫做队尾(rear)，允许删除的一端叫做队首(front)。&lt;/p&gt;
&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;链式队列：用链表实现。&lt;/li&gt;
&lt;li&gt;静态队列：用数组实现。(&lt;em&gt;为了解决假溢出现象，静态队列通常都必须是循环队列&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://SkyHive.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://SkyHive.github.io/2017/10/11/%E6%A0%88/"/>
    <id>http://SkyHive.github.io/2017/10/11/栈/</id>
    <published>2017-10-11T05:18:27.000Z</published>
    <updated>2017-10-11T05:39:37.250Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一种<strong>先进后出</strong>的线性数据结构，规定只允许在一端进行插入和删除元素的操作。其中进栈操作又叫做压栈（Push），出栈操作又叫做弹出（Pop）。允许进行操作的一端叫做栈顶（top），另一端叫做栈底（base）。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>顺序栈：数组实现</li><li>链式栈：链表实现<a id="more"></a><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4></li></ul><h5 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h5><img src="http://old5ws7lp.bkt.clouddn.com/images/stack.png"><p>1.构建栈的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1024<span class="comment">//定义栈的空间大小</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">stack</span>&#123;</div><div class="line">  <span class="keyword">int</span> data[MAXSIZE];</div><div class="line">  <span class="keyword">int</span> top;</div><div class="line">&#125;Stack;</div></pre></td></tr></table></figure><p>2.初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stack *<span class="title">Init</span><span class="params">()</span></span>&#123;</div><div class="line">    Stack <span class="built_in">stack</span>;</div><div class="line">    <span class="built_in">stack</span> = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">stack</span>)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!"</span>);</div><div class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">      <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;<span class="comment">//C语言数组下标从0开始</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Init successfully!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="built_in">stack</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3.判断栈是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The stack is empty!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.判断栈是否满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top == MAXSIZE<span class="number">-1</span>)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The satck is full!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.进栈操作（Push）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack* <span class="built_in">stack</span>,<span class="keyword">int</span> item)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(isFull(<span class="built_in">stack</span>))&#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">  <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = item;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>入站操作先移动Top，再压入元素</em></p><p>6.出栈操作（Pop）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(isEmpty(<span class="built_in">stack</span>))&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">-99</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];<span class="comment">//返回被弹出的元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>7.遍历操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Stack* satck)</span></span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The items in the stack are:\n"</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">stack</span>-&gt;top;i &gt;= <span class="number">0</span>;i--)&#123;</div><div class="line">  <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,<span class="built_in">stack</span>-&gt;data[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h5><img src="http://old5ws7lp.bkt.clouddn.com/images/stack1.png"><p>1.构建栈的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> node&#123;</div><div class="line">  <span class="keyword">int</span> data;</div><div class="line">  <span class="keyword">struct</span> node* next;</div><div class="line">&#125;Node;</div></pre></td></tr></table></figure><p>2.初始化栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node* <span class="title">Init</span><span class="params">()</span></span>&#123;</div><div class="line">  Node* s;</div><div class="line">  s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">  <span class="keyword">if</span>(!s)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Init successfully!"</span>);</div><div class="line">      s-&gt;next = <span class="literal">NULL</span>;</div><div class="line">      <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3.判断栈是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Node* s)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> (s-&gt;next == <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.进栈操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Node* s,<span class="keyword">int</span> item)</span></span>&#123;</div><div class="line">  Node* node;<span class="comment">//为插入的元素构建一个节点</span></div><div class="line">  node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">  <span class="keyword">if</span>(!node)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Memory allocation failed!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">  node-&gt;data = item;</div><div class="line">  node-&gt;next = s-&gt;next;<span class="comment">//这里写成node-&gt;next = NULL应该也可以吧</span></div><div class="line">  s-&gt;next = node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>5.出栈操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Node* s)</span></span>&#123;</div><div class="line">  Node* Top;</div><div class="line">  <span class="keyword">int</span> data;</div><div class="line">  <span class="keyword">if</span>(isEmpty(s))&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The stack is empty!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="number">-99</span>;</div><div class="line">&#125;</div><div class="line">  Top = s-&gt;next;</div><div class="line">  s-&gt;next = Top-&gt;next;</div><div class="line">  data = Top-&gt;data;</div><div class="line">  <span class="built_in">free</span>(Top);</div><div class="line">  <span class="keyword">return</span> data;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>6.遍历操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Node* s)</span></span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"The items in the stack are:\n"</span>);</div><div class="line">  Node* p;</div><div class="line">    p = s;</div><div class="line">  <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;data);</div><div class="line">      p = p-&gt;next;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈是一种&lt;strong&gt;先进后出&lt;/strong&gt;的线性数据结构，规定只允许在一端进行插入和删除元素的操作。其中进栈操作又叫做压栈（Push），出栈操作又叫做弹出（Pop）。允许进行操作的一端叫做栈顶（top），另一端叫做栈底（base）。&lt;/p&gt;
&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;顺序栈：数组实现&lt;/li&gt;
&lt;li&gt;链式栈：链表实现
    
    </summary>
    
      <category term="Algorithm" scheme="http://SkyHive.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建属于自己的Shadowsocks服务</title>
    <link href="http://SkyHive.github.io/2017/08/11/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Shadowsocks%E6%9C%8D%E5%8A%A1/"/>
    <id>http://SkyHive.github.io/2017/08/11/搭建属于自己的Shadowsocks服务/</id>
    <published>2017-08-11T04:52:41.000Z</published>
    <updated>2017-10-11T05:39:21.775Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直想自己搭一个Shadowsocks服务，并且利用服务器学习一些技术知识，但是国内的服务器实在是贵得很啊，像我这种苦逼大学生根本玩不起，无奈之下只好各种google百度，最后找到了一些国外的VPS资源</p><ul><li>BandwagonHost(<a href="http://banwagong.cn/fangan.html" target="_blank" rel="external">搬瓦工VPS</a>)：据观察搬瓦工这个VPS还是算计比较便宜的，年付20刀，平均下来每个月只有1.6刀，而且套餐很良心很良心,512MB的内存，10GB的SSD，1TB的流量是不是比国内很多主机都划算的很。<img src="http://old5ws7lp.bkt.clouddn.com/images/DO1.png"><a id="more"></a></li><li><a href="https://www.vultr.com/" target="_blank" rel="external">Vultr</a>:同样也是SSD VPS,这个套餐看起来也还是很不错的，只不过每月两刀的套餐总是能被抢空。<img src="http://old5ws7lp.bkt.clouddn.com/images/DO2.png"></li><li>Digital Ocean：也是我目前正在使用的，大家可以<a href="https://m.do.co/c/0b7931b5f2e8" target="_blank" rel="external">点击此链接注册</a>，通过这个优惠链接注册的小伙伴们会直接获得10美刀的额度在你的账户余额里。而且他的这个套餐也是很诱人的，同样的SSD VPS，20G硬盘，每月1TB流量，1G的带宽，只不过这个费用看起来太贵了，一个月需要五美刀。<img src="http://old5ws7lp.bkt.clouddn.com/images/DO3.png">但是事情有这么简单吗？</li></ul><p>当然没有，鼎鼎大名的gayhub上有个提供给<a href="https://education.github.com" target="_blank" rel="external">学生的pack</a>，里面有各种东西，有需要者可以根据需要去使用，其中就有Digital Ocean的价值50刀的credit。好了，既然有了这等美差，下面该怎么搞呢？</p><p>既然是给学生用的，那么github肯定要判断你学生的身份，这个时候你需要一个edu邮箱，基本上国内很多大学都会给学生使用edu邮箱的，用你的edu邮箱去注册github；或者有的已经注册过github的怎么办呢，登录帐号后进入setting选项，在右侧的Email中添加一个email地址，然后验证就好了。进入<a href="https://education.github.com" target="_blank" rel="external">学生包申请页面</a>，点击<code>GET your pack</code>，然后就正常填写信息即可，之后我们就能获得需要的优惠码了。<br><img src="http://old5ws7lp.bkt.clouddn.com/images/DO4.png"><br>下面我<a href="https://m.do.co/c/0b7931b5f2e8" target="_blank" rel="external">注册Digital Ocean</a>，正常的注册步骤，邮箱注册可以使用任意邮箱；邮箱验证结束之后进入到第二部验证，这一步需要有<code>信用卡</code>或者<code>PayPal</code>之类的(如果你我皆是大穷逼的话，可以和我一样选择使用<code>PayPal</code>，<a href="https://www.paypal.com" target="_blank" rel="external">注册</a>一个PayPal再去绑定一张卡即可),选择<code>PayPal</code>验证，然后支付5美刀即可完成验证，第三步是创建一个Droplet，即创建一个VPS，至于配置：</p><ul><li><p>系统根据你的需要去选择</p></li><li><p>size选最小的$5/mo即可，你要是有钱我也不说什么了</p></li><li><p>数据中心的话，推荐洛杉矶1号机房吧，至于他们说的什么新加坡，我亲测慢成狗。</p></li></ul><p>之前注册的时候花了5美元，送了10美元，加上优惠码的50美元，一共就有65美元了，实际花费五美元，使用十三个月，是不是物超所值。</p><p>VPS创建完之后，Digital Ocean会把IP、账号和密码都发到你的注册邮箱，然后你就可以利用putty或者ssh登录到服务器啦！</p><hr><p>下面就开始搭建我们的<code>Shadowsocks</code>服务：</p><h4 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h4><p>首先我们要安装<code>Shadowsocks</code>，由于<code>Shadowsocks</code>是用<code>python</code>写的，我们先安装<code>pip</code><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#由于我用的是Ubuntu的系统，其他系统的用户请自行Google</span></div><div class="line">apt-get <span class="keyword">install</span> python-pip</div><div class="line">pip <span class="keyword">install</span> shadowsocks</div></pre></td></tr></table></figure></p><h4 id="优化Shadowsocks性能"><a href="#优化Shadowsocks性能" class="headerlink" title="优化Shadowsocks性能"></a>优化Shadowsocks性能</h4><p>按照SS官方Wiki，我们进行优化：</p><p>创建<code>local.conf</code>配置文件<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.<span class="keyword">d</span>/<span class="keyword">local</span>.<span class="keyword">conf</span></div></pre></td></tr></table></figure></p><p>进入编辑模式之后输入以下内容：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># max open files</span></div><div class="line">fs.file-max = <span class="number">51200</span></div><div class="line"><span class="meta"># max read buffer</span></div><div class="line">net.core.rmem_max = <span class="number">67108864</span></div><div class="line"><span class="meta"># max write buffer</span></div><div class="line">net.core.wmem_max = <span class="number">67108864</span></div><div class="line"><span class="meta"># default read buffer</span></div><div class="line">net.core.rmem_default = <span class="number">65536</span></div><div class="line"><span class="meta"># default write buffer</span></div><div class="line">net.core.wmem_default = <span class="number">65536</span></div><div class="line"><span class="meta"># max processor input queue</span></div><div class="line">net.core.netdev_max_backlog = <span class="number">4096</span></div><div class="line"><span class="meta"># max backlog</span></div><div class="line">net.core.somaxconn = <span class="number">4096</span></div><div class="line"></div><div class="line"><span class="meta"># resist SYN flood attacks</span></div><div class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></div><div class="line"><span class="meta"># reuse timewait sockets when safe</span></div><div class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></div><div class="line"><span class="meta"># turn off fast timewait sockets recycling</span></div><div class="line">net.ipv4.tcp_tw_recycle = <span class="number">0</span></div><div class="line"><span class="meta"># short FIN timeout</span></div><div class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span></div><div class="line"><span class="meta"># short keepalive time</span></div><div class="line">net.ipv4.tcp_keepalive_time = <span class="number">1200</span></div><div class="line"><span class="meta"># outbound port range</span></div><div class="line">net.ipv4.ip_local_port_range = <span class="number">10000</span> <span class="number">65000</span></div><div class="line"><span class="meta"># max SYN backlog</span></div><div class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">4096</span></div><div class="line"><span class="meta"># max timewait sockets held by system simultaneously</span></div><div class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">5000</span></div><div class="line"><span class="meta"># turn on TCP Fast Open on both client and server side</span></div><div class="line">net.ipv4.tcp_fastopen = <span class="number">3</span></div><div class="line"><span class="meta"># TCP receive buffer</span></div><div class="line">net.ipv4.tcp_rmem = <span class="number">4096</span> <span class="number">87380</span> <span class="number">67108864</span></div><div class="line"><span class="meta"># TCP write buffer</span></div><div class="line">net.ipv4.tcp_wmem = <span class="number">4096</span> <span class="number">65536</span> <span class="number">67108864</span></div><div class="line"><span class="meta"># turn on path MTU discovery</span></div><div class="line">net.ipv4.tcp_mtu_probing = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="meta"># for high-latency network</span></div><div class="line">net.ipv4.tcp_congestion_control = hybla</div><div class="line"></div><div class="line"><span class="meta"># for low-latency network, use cubic instead</span></div><div class="line"><span class="meta"># net.ipv4.tcp_congestion_control = cubic</span></div></pre></td></tr></table></figure></p><p>保存退出后，执行以下命令使之生效：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl <span class="comment">--system</span></div></pre></td></tr></table></figure></p><h4 id="配置Shadowsocks配置文件"><a href="#配置Shadowsocks配置文件" class="headerlink" title="配置Shadowsocks配置文件"></a>配置Shadowsocks配置文件</h4><p>在<code>/etc/</code>下创建配置文件：<code>vim /etc/shadowsocks.json</code><br>然后进行编辑：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"server"</span>:<span class="string">"my_server_ip"</span>,</div><div class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>,</div><div class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line">    <span class="attr">"password"</span>:<span class="string">"mypassword"</span>,</div><div class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>        #这里的加密方式也可以选择其他的类型，自行把握</div><div class="line">    <span class="string">"fast_open"</span>:<span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="最后启用Shadowsocks服务端功能"><a href="#最后启用Shadowsocks服务端功能" class="headerlink" title="最后启用Shadowsocks服务端功能"></a>最后启用Shadowsocks服务端功能</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssserver -c /etc/shadowsocks<span class="selector-class">.json</span> -d start &amp;</div></pre></td></tr></table></figure><blockquote><p><code>nohup</code>是把运行日志输出到当前用户主目录下的<code>nohup.out</code>文件中</p></blockquote><p>到这里VPS上的Shadowsocks服务基本上就搭建完毕了，接下来的事情我想大家应该都会做了吧，爬上梯子开始翻墙吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直想自己搭一个Shadowsocks服务，并且利用服务器学习一些技术知识，但是国内的服务器实在是贵得很啊，像我这种苦逼大学生根本玩不起，无奈之下只好各种google百度，最后找到了一些国外的VPS资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BandwagonHost(&lt;a href=&quot;http://banwagong.cn/fangan.html&quot;&gt;搬瓦工VPS&lt;/a&gt;)：据观察搬瓦工这个VPS还是算计比较便宜的，年付20刀，平均下来每个月只有1.6刀，而且套餐很良心很良心,512MB的内存，10GB的SSD，1TB的流量是不是比国内很多主机都划算的很。&lt;img src=&quot;http://old5ws7lp.bkt.clouddn.com/images/DO1.png&quot;&gt;
    
    </summary>
    
      <category term="Other" scheme="http://SkyHive.github.io/categories/Other/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下PHP验证码不显示问题</title>
    <link href="http://SkyHive.github.io/2017/07/14/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8BPHP%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://SkyHive.github.io/2017/07/14/解决Ubuntu下PHP验证码不显示问题/</id>
    <published>2017-07-14T08:41:26.000Z</published>
    <updated>2017-07-14T08:42:02.027Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在帮别人写一个注册登录功能的页面，用到了简单的TP框架，但是在我自己的Ubuntu环境下发现验证码出了问题——验证码图片显示不出来。</p><p>我将图片单独拉出来，发现错误提示如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call to <span class="literal">undefined</span> <span class="function"><span class="keyword">function</span> <span class="title">imagecreate</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p>百度一问就找到了答案，原来这是由于没有安装或者开启PHP的GD库导致的，既然这样我只需要安装一下GD库就解决了：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install php7.0-<span class="built_in">gd</span></div></pre></td></tr></table></figure></p><p>安装完毕后将Apache服务器重启，如果是Nginx的话，则可用可不用</p><p>如果是Windows环境的话，打开PHP安装目录下的php.ini配置文件，找到：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;extension=php_gd2.dll</span></div></pre></td></tr></table></figure></p><p>去掉注释，重启服务就解决了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天在帮别人写一个注册登录功能的页面，用到了简单的TP框架，但是在我自己的Ubuntu环境下发现验证码出了问题——验证码图片显示不出来。&lt;/p&gt;
&lt;p&gt;我将图片单独拉出来，发现错误提示如下：&lt;br&gt;&lt;figure class=&quot;highlight actionscript
      
    
    </summary>
    
      <category term="PHP" scheme="http://SkyHive.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下Apache不解析PHP问题</title>
    <link href="http://SkyHive.github.io/2017/07/13/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8BApache%E4%B8%8D%E8%A7%A3%E6%9E%90PHP%E9%97%AE%E9%A2%98/"/>
    <id>http://SkyHive.github.io/2017/07/13/解决Ubuntu下Apache不解析PHP问题/</id>
    <published>2017-07-13T12:00:22.000Z</published>
    <updated>2017-07-13T12:02:13.924Z</updated>
    
    <content type="html"><![CDATA[<p>这两天笔者遇到了一个很操蛋的问题——Apache无法解析PHP代码了，之前一直用的挺好的，突然就挂了，然后在网上疯狂的找解决办法，但是大都是php5的版本，而我却是7的版本，我就先顺便把5版本的解决方法贴出来：</p><blockquote><p>修改apache的配置文件httpd.conf<br><a id="more"></a><br>在httpd.conf中找到：<br><code>AddType application/x-gzip .gz .tgz</code><br>在该行下面添加<br><code>AddType application/x-httpd-php .php</code></p><p>再找继续找到：<br><code>DirectoryIndex index.html</code>，<br>把此行修改成<br><code>DirectoryIndex index.html index.htm index.php</code></p><p>再找到：<br><code>#ServerName www.example.com:80</code><br>改成<br><code>ServerName localhost:80</code></p></blockquote><p>然而Ubuntu下的Apache并没有httpd.conf这个配置文件，而是通过一个apache2.conf来引用每个部分的配置文件，这样在一个配置包里找到那一句配置也并不简单，而且我还没有找到。。。</p><p>不过皇天不负有心人，终于是找到了解决办法：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install libapache2-<span class="keyword">mod</span>-php</div></pre></td></tr></table></figure></p><p>这一步安装了apache的扩展包，可以用于解析php，我觉得不管是7版本还是5版本都可以适用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天笔者遇到了一个很操蛋的问题——Apache无法解析PHP代码了，之前一直用的挺好的，突然就挂了，然后在网上疯狂的找解决办法，但是大都是php5的版本，而我却是7的版本，我就先顺便把5版本的解决方法贴出来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改apache的配置文件httpd.conf&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>一个学习Python的小游戏</title>
    <link href="http://SkyHive.github.io/2017/04/21/%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%B9%A0Python%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>http://SkyHive.github.io/2017/04/21/一个学习Python的小游戏/</id>
    <published>2017-04-21T13:44:57.000Z</published>
    <updated>2017-04-25T08:58:21.390Z</updated>
    
    <content type="html"><![CDATA[<p>笔者最近在自学Python的过程中想起曾经有人推荐过的一款学习编程的小游戏，叫做<a href="https://cn.codecombat.com" target="_blank" rel="external">Codecombat</a>，通过玩游戏的方式学习编程语言的语法规则。<br><a id="more"></a><br><img src="http://old5ws7lp.bkt.clouddn.com/images/codecombat.png"></p><p>游戏有很多关卡，每个关卡都会有之前没有学过的语法，学习的难度是逐渐上升的，用游戏的方式将学习者带入比起看起枯燥的书本文字效果要好的多。</p><img src="http://old5ws7lp.bkt.clouddn.com/images/level.png"><p>当然这里除了有Python之外还有Javascript等脚本语言可以学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者最近在自学Python的过程中想起曾经有人推荐过的一款学习编程的小游戏，叫做&lt;a href=&quot;https://cn.codecombat.com&quot;&gt;Codecombat&lt;/a&gt;，通过玩游戏的方式学习编程语言的语法规则。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://SkyHive.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL进阶</title>
    <link href="http://SkyHive.github.io/2017/04/17/SQL%E8%BF%9B%E9%98%B6/"/>
    <id>http://SkyHive.github.io/2017/04/17/SQL进阶/</id>
    <published>2017-04-17T09:04:51.000Z</published>
    <updated>2017-04-17T09:11:47.675Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道select的基本用法<code>select &lt;字段名&gt; from &lt;表名&gt; [where &lt;限制条件&gt;]</code>，然而<code>select</code>语句后面还可以跟很多限制条件。我们这次用user表来作为示范，下面是user表的结构：<br><a id="more"></a></p><img src="http://old5ws7lp.bkt.clouddn.com/images/user.png"><h4 id="Between、And、In、-lt-、-gt-、-lt-、-gt-等条件查询："><a href="#Between、And、In、-lt-、-gt-、-lt-、-gt-等条件查询：" class="headerlink" title="Between、And、In、&lt;=、&gt;=、&lt;、&gt;等条件查询："></a>Between、And、In、&lt;=、&gt;=、&lt;、&gt;等条件查询：</h4><p>通过<code>select * from table where id between 1 and 3</code>和<code>select * from table where id &gt;=1 and id &lt;= 3</code>的返回结果，我们可以发现<code>between and</code>和<code>&gt;= and &lt;=</code>是等同的。<br><img src="http://old5ws7lp.bkt.clouddn.com/images/between.png"><br><img src="http://old5ws7lp.bkt.clouddn.com/images/between2.png"><br>如果我们要查询的条件不是一个连续的数值，可以用<code>in</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">4</span>)</div></pre></td></tr></table></figure></p><h4 id="locate-函数：locate-substr-str"><a href="#locate-函数：locate-substr-str" class="headerlink" title="locate()函数：locate(substr,str)"></a>locate()函数：<code>locate(substr,str)</code></h4><p>这个函数返回<code>substr</code>在字符串<code>str</code>中的第一个出现的位置，如果不存在则值为0<br><img src="http://old5ws7lp.bkt.clouddn.com/images/locate.png"></p><h4 id="Count-函数"><a href="#Count-函数" class="headerlink" title="Count()函数:"></a>Count()函数:</h4><ul><li>count(字段名)：返回指定列的值的数目，但是字段值为<code>NULL</code>时不会被计算进去。<code>select count(字段名) from &lt;表名&gt;</code></li><li>count(<em> )：返回表中的记录数，字段值为<code>NULL</code>时会被计算进去。`select count(</em>) from &lt;表名&gt;`</li></ul><h4 id="Distinct语句："><a href="#Distinct语句：" class="headerlink" title="Distinct语句："></a>Distinct语句：</h4><p>Distinct语句用于去除重复行，比如：<code>select distinct * from &lt;表名&gt;</code>。<br>其他的语句或函数都可以和<code>distinct</code>配合使用，比如：<code>count(distinct &lt;字段名&gt;)</code>可以去除重复行统计行数，但是<code>count(distinct *)</code>是<strong>不被允许</strong>的</p><h4 id="Union语句："><a href="#Union语句：" class="headerlink" title="Union语句："></a>Union语句：</h4><p>Union语句可以将两个<code>select</code>语句的结果集组合成一个：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt;= <span class="number">3</span>) <span class="keyword">union</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>)</div></pre></td></tr></table></figure></p><p>当我们使用<code>union</code>语句的时候，默认去除了重复行，和<code>distinct</code>的效果一样，如果要显示所有的结果，则要使用<code>union all</code>语句。</p><h4 id="Drder-by语句："><a href="#Drder-by语句：" class="headerlink" title="Drder by语句："></a>Drder by语句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> &lt;字段名&gt; [<span class="keyword">asc</span>/<span class="keyword">desc</span>]</div></pre></td></tr></table></figure><p>其中<code>asc</code>是默认的排序，为升序，<code>desc</code>为降序。<br>当然order by后面可以跟很多个字段，如：<code>select * from table order by info desc,id asc</code>,这个语句意为先按<code>info</code>字段降序，若<code>info</code>字段值相同的情况下，再按<code>id</code>字段升序。而且，<code>NULL</code>默认为值最小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道select的基本用法&lt;code&gt;select &amp;lt;字段名&amp;gt; from &amp;lt;表名&amp;gt; [where &amp;lt;限制条件&amp;gt;]&lt;/code&gt;，然而&lt;code&gt;select&lt;/code&gt;语句后面还可以跟很多限制条件。我们这次用user表来作为示范，下面是user表的结构：&lt;br&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://SkyHive.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Dict和Set</title>
    <link href="http://SkyHive.github.io/2017/04/12/Dict%E5%92%8CSet/"/>
    <id>http://SkyHive.github.io/2017/04/12/Dict和Set/</id>
    <published>2017-04-12T14:16:27.000Z</published>
    <updated>2017-04-12T14:26:32.496Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h4><p>Python内置了字典Dict（全称Dictionary），使用键-值（key-value）存储，具有极快的查找速度。Dict的查找原理和查字典类似，key就相当于字典的索引，Python可以通过key计算出所对应的value存放的内存地址，直接取出，所以查找速度快。<br>Dict的初始化很简单，语法如下：</p><a id="more"></a><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; dict = &#123;key1' : <span class="type">value1</span>, <span class="symbol">'key2</span>' = value2, <span class="symbol">'key3</span>' = value3&#125;</div><div class="line">&gt;&gt;&gt; dict[<span class="symbol">'key2</span>']</div><div class="line">value2</div></pre></td></tr></table></figure><p>一个key只能对应一个value，所以当我们对一个key多次赋值时会将前一个value覆盖掉。由于需要查找的key不存在时，dict会报错，为了避免key不存在的情况，Python提供了两种方法：</p><ul><li><p>通过<code>in</code>判断，如果key存在，就返回<code>True</code>，反之返回<code>False</code>：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; `key` <span class="keyword">in</span> dict</div></pre></td></tr></table></figure></li><li><p>通过<code>get</code>判断，如果key不存在就返回None（<em>返回None的时候交互式命令行不显示结果</em>），也可以是自己指定返回的内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; dict.get(<span class="string">'key'</span>)     <span class="comment">#返回None</span></div><div class="line"><span class="meta">&gt;&gt;</span>&gt; dict.get(<span class="string">'key'</span>,-<span class="number">1</span>)      <span class="comment">#返回自己指定的值`-1`</span></div></pre></td></tr></table></figure></li></ul><p>删除Dict可以使用<code>dict.pop(key)</code>方法，对应的value也会从dict中删除。<br>Dict内部的存放顺序和key的放入没有关系，Dict的查找和插入速度不会随着key的增加而变慢，需要占用大量的内存，是一种用空间来换取时间的方法。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set和Dict类似，也是一组key的集合，但是不存储value。由于key不能重复，所以在set中没有重复的key。要创建一个set需要提供一个list作为输入的集合：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div></pre></td></tr></table></figure></p><p>重复的元素会被set自动过滤，可以通过<code>add(key)</code>方法向set添加元素，通过<code>remove(key)</code>方法删除元素。我们可以将set看作数学意义上的集合，因此，两个set之间可以做数学意义上的交(&amp;)、并(|)集等运算</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Dict&quot;&gt;&lt;a href=&quot;#Dict&quot; class=&quot;headerlink&quot; title=&quot;Dict&quot;&gt;&lt;/a&gt;Dict&lt;/h4&gt;&lt;p&gt;Python内置了字典Dict（全称Dictionary），使用键-值（key-value）存储，具有极快的查找速度。Dict的查找原理和查字典类似，key就相当于字典的索引，Python可以通过key计算出所对应的value存放的内存地址，直接取出，所以查找速度快。&lt;br&gt;Dict的初始化很简单，语法如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://SkyHive.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://SkyHive.github.io/2017/04/07/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://SkyHive.github.io/2017/04/07/Python基础/</id>
    <published>2017-04-07T01:25:45.000Z</published>
    <updated>2017-05-19T08:04:52.869Z</updated>
    
    <content type="html"><![CDATA[<p><em>最近在自学Python，所以一边学也一边总结一些知识点</em></p><h4 id="Python的输出"><a href="#Python的输出" class="headerlink" title="Python的输出"></a>Python的输出</h4><p>Python的输出和C语言类似，在<code>print()</code>函数里加上字符串（用单引号或者双引号，但是不能混用），例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">'Hello world!'</span>)</div></pre></td></tr></table></figure></p><p><code>print()</code>函数也可以接受多个字符串，用逗号隔开即可。<code>print()</code>函数依次打印字符串，每遇到逗号就会输出一个空格。<br><code>print()</code>也可以打印整数或者计算结果，例如：<br><a id="more"></a><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print('<span class="number">5</span>+<span class="number">3</span>=',<span class="number">5</span>+<span class="number">3</span>)</div></pre></td></tr></table></figure></p><p><em>注：对于<code>5+3</code>，python解释器会自动计算出结果，但是<code>&#39;5+3=&#39;</code>是字符串而非数学公式</em></p><h4 id="Python的输入"><a href="#Python的输入" class="headerlink" title="Python的输入"></a>Python的输入</h4><p>Pyhton提供了<code>input()</code>函数，可以让用户输入字符串，并且存到一个变量里，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; info = input()</div></pre></td></tr></table></figure></p><p>输入任意字符后按下回车完成输入，输入的内容就被存放在变量<code>info</code>里面了。<br><code>input()</code>函数可以显示一个字符串来提示用户，如：<code>input(&#39;please input something:&#39;)</code></p><h4 id="Python的数据类型"><a href="#Python的数据类型" class="headerlink" title="Python的数据类型"></a>Python的数据类型</h4><ul><li>整数：Python可以处理任意大小的整数，包括负整数。</li><li>浮点数：与C语言一样，可以用数学法也可以用科学记数法（把10用e替代）表示。</li><li>字符串：字符串使用单引号或者双引号括起来的任意文本；如果文本中包含<code>&#39;</code>和<code>&quot;</code>可以用转义字符<code>\</code>来表示。</li><li>布尔值：一个布尔值只有<code>True</code>和<code>False</code>两种值（注意大小写）；布尔值可以用<code>and（与运算）</code>、<code>or（或运算）</code>和<code>not（非运算）</code>运算。</li><li>空值：空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为0，因为0是有意义的整数，而<code>None</code>是一个特殊的空值；类似于C语言里面的<code>NULL</code>。</li><li>变量：和C语言类似，变量名必须是大小写英文、数字和下划线的组合，且不能用数字开头；如：<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">a</span> = <span class="number">123</span></div></pre></td></tr></table></figure></li></ul><p>这种变量本身类型不固定的语言称为动态语言，与之对应的是静态语言。静态语言在定义变量是必须指定变量类型，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int <span class="selector-tag">a</span> = <span class="number">123</span></div></pre></td></tr></table></figure></p><p>和静态语言相比，动态语言更灵活。</p><ul><li>常量：所谓常量就是不能变的变量，在Python中，通常用全部大写的变量名表示常量。</li></ul><h4 id="Python的整数除法和取余"><a href="#Python的整数除法和取余" class="headerlink" title="Python的整数除法和取余"></a>Python的整数除法和取余</h4><ul><li><code>/</code>：这种整数的除法得到的结果是浮点数，即使两个整数恰好整除结果也是浮点数。</li><li><code>//</code>：这种除法也称为地板除，两个整数的相除结果仍然为整数，和C语言中的整数除法一样，整数除法结果为小数时取整数部分。</li><li><code>%</code>：与C语言的取余一样，结果为两整数相除的余数。</li></ul><h4 id="Python的list"><a href="#Python的list" class="headerlink" title="Python的list"></a>Python的list</h4><p>list类似于数组的概念，可以随时添加和删除元素；与数组一样，<code>list[]</code>的索引是从0开始的，但是访问元素时要确保索引不要越界，可以用<code>len()</code>函数来获取元素的个数，如：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="built_in">len</span>(<span class="keyword">list</span>)       #变量<span class="keyword">list</span>是一个<span class="keyword">list</span></div></pre></td></tr></table></figure></p><p>所以最后一个元素的索引是<code>len(list)-1</code>，当然也可以用<code>-1</code>来做索引，直接获取最后一个元素<code>list[-1]</code>，以此类推可以用<code>-2</code>、<code>-3</code>来获取倒数第二个的、倒数第三个元素。</p><p>Python提供<code>lsit.insert()</code>函数将元素插入到特定的位置，如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; list.insert(x,<span class="string">'info'</span>)<span class="comment">#x为想插入元素位置的索引号，info为想插入的 元素</span></div></pre></td></tr></table></figure></p><p>也可以用<code>list.addend()</code>函数将元素插入到末尾，如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; list.addend(<span class="string">'info'</span>)     <span class="comment">#info为想插入的元素</span></div></pre></td></tr></table></figure></p><p>想要删除list末尾元素用<code>list.pop()</code>函数，想要删除指定位置的元素，用<code>list.pop(x)</code>方法，其中<code>x</code>是索引位置。list可以直接赋值，而且list中的元素类型也可以不同。</p><h4 id="Python的tuple"><a href="#Python的tuple" class="headerlink" title="Python的tuple"></a>Python的tuple</h4><p>这是Python的另一个有序列表，叫做元组（tuple）。tuple和list类似，但是tuple一旦初始化就不能进行修改了；我们依然可以使用<code>tuple[0]</code>、<code>tuple[-1]</code>来获取元素。<br>由于tuple不可变，所以相比list更加安全，所以能用tuple就尽量使用tuple。下面说一下tuple的定义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)       <span class="comment">#正常的tuple定义</span></div><div class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = ()      <span class="comment">#定义空的tuple</span></div></pre></td></tr></table></figure></p><p>但是当定义一个元素的tuple的时候，如果写成这样：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = (<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p>由于小括号<code>()</code>既可以表示tuple又可以表示数学公式中的小括号，就产生了歧义。因此，Python规定这种情况下<code>()</code>按照数学公式的小括号计算，结果即为<code>1</code>，所以，只有一个元素的tuple定义是要加一个逗号<code>,</code>来消除歧义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = (<span class="number">1</span>,)</div></pre></td></tr></table></figure></p><p><em>当然了，tuple的元素中如果包含一个list的话，list的元素是可以改变的</em></p><h4 id="Python的条件判断"><a href="#Python的条件判断" class="headerlink" title="Python的条件判断"></a>Python的条件判断</h4><p>和C语言类似，Python的条件判断的语法如下：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if <span class="params">&lt;判断条件<span class="number">1</span>&gt;</span>:</div><div class="line">    <span class="params">&lt;执行代码&gt;</span></div><div class="line">elif <span class="params">&lt;判断条件<span class="number">2</span>&gt;</span>:</div><div class="line">    <span class="params">&lt;执行代码&gt;</span></div><div class="line">elif <span class="params">&lt;判断条件<span class="number">3</span>&gt;</span>:</div><div class="line">     <span class="params">&lt;执行代码&gt;</span></div><div class="line">        …………</div><div class="line"><span class="symbol">else:</span></div><div class="line">     <span class="params">&lt;执行代码&gt;</span></div></pre></td></tr></table></figure></p><p>我们可以通过使用之前说过的<code>input()</code>函数的输入进行条件判断，但是有一个需要注意的地方，<strong><code>input()</code>函数返回的数据类型是<code>str</code>，不能直接和整数比较，所以必须要先使用<code>int()</code>函数将<code>str</code>转换为整数。</strong></p><h4 id="Python的循环"><a href="#Python的循环" class="headerlink" title="Python的循环"></a>Python的循环</h4><h5 id="for……in"><a href="#for……in" class="headerlink" title="for……in:"></a>for……in:</h5><p>这个循环可以将list或tuple中的元素遍历出来，看个例子：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">num</span> = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>]</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">num</span>:</div><div class="line">    <span class="built_in">print</span>(x)</div></pre></td></tr></table></figure></p><p>执行这段代码，会依次打印每一个元素，所以<code>for x in ……</code>就是把每个元素带入变量<code>x</code>，然后执行缩进块的语句。有了这个循环我们就可以做求和了，不过我们要从1写到100确实有点困难，幸好Python提供了<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; <span class="type">list</span>(range(<span class="number">5</span>))</div><div class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]         #range(<span class="number">5</span>)生成的是从<span class="number">0</span>开始小于<span class="number">5</span>的整数</div></pre></td></tr></table></figure></p><h5 id="while"><a href="#while" class="headerlink" title="while:"></a>while:</h5><p>和C语言类似，条件满足就循环，条件不满足时就退出循环。语法如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while <span class="tag">&lt;<span class="name">判断条件</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">执行语句</span>&gt;</span></div></pre></td></tr></table></figure></p><h5 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue:"></a>break和continue:</h5><p>和C语言类似，<code>break</code>可以提前退出循环，<code>continue</code>可以跳过当前循环，直接进入下一次循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;最近在自学Python，所以一边学也一边总结一些知识点&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;Python的输出&quot;&gt;&lt;a href=&quot;#Python的输出&quot; class=&quot;headerlink&quot; title=&quot;Python的输出&quot;&gt;&lt;/a&gt;Python的输出&lt;/h4&gt;&lt;p&gt;Python的输出和C语言类似，在&lt;code&gt;print()&lt;/code&gt;函数里加上字符串（用单引号或者双引号，但是不能混用），例如：&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt; print(&lt;span class=&quot;string&quot;&gt;&#39;Hello world!&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print()&lt;/code&gt;函数也可以接受多个字符串，用逗号隔开即可。&lt;code&gt;print()&lt;/code&gt;函数依次打印字符串，每遇到逗号就会输出一个空格。&lt;br&gt;&lt;code&gt;print()&lt;/code&gt;也可以打印整数或者计算结果，例如：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://SkyHive.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL语句的基本操作</title>
    <link href="http://SkyHive.github.io/2017/04/04/SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://SkyHive.github.io/2017/04/04/SQL语句的基本操作/</id>
    <published>2017-04-04T04:44:13.000Z</published>
    <updated>2017-04-07T04:40:08.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ol><li>创建数据库： <code>CREATE DATABASE &lt;数据库名&gt; [其他选项]</code></li><li>使用数据库： <code>USE &lt;数据库名&gt;</code></li><li>修改数据库： <code>ALTER DATABASE &lt;数据库名&gt;</code></li><li>删除数据库： <code>DROP DATABASE &lt;数据库名&gt;</code></li></ol><a id="more"></a><h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><ol><li><p>创建表：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE &lt;表名&gt;</div><div class="line">（</div><div class="line">     &lt;列名<span class="number">1</span>&gt;&lt;数据类型&gt;<span class="meta">[&lt;列级完整性约束&gt;]</span>,</div><div class="line">    <span class="meta">[&lt;列名n&gt;&lt;数据类型&gt;[&lt;列级完整性约束&gt;]</span>]</div><div class="line"> ）;</div><div class="line">例：</div><div class="line">    create table studets</div><div class="line">    (</div><div class="line">        id int not <span class="keyword">null</span> auto_increment primary key,</div><div class="line">        name varchar(<span class="number">8</span>) not <span class="keyword">null</span>,</div><div class="line">        sex varchar(<span class="number">5</span>) not <span class="keyword">null</span>,</div><div class="line">        score int(<span class="number">5</span>) not <span class="keyword">null</span></div><div class="line">    )</div></pre></td></tr></table></figure></li><li><p>修改基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">add</span> &lt;列名&gt; &lt;列数据类型&gt; [<span class="keyword">after</span> 插入位置];         <span class="comment">--增加列</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">change</span> &lt;列名&gt; &lt;列新名&gt; &lt;新数据类型&gt;;              <span class="comment">--修改列</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">drop</span> &lt;列名&gt;;                         <span class="comment">--删除列</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">rename</span> &lt;新表名&gt;;                     <span class="comment">--重命名表</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;                                       <span class="comment">--删除表</span></div></pre></td></tr></table></figure></li><li><p>表的基本操作</p></li></ol><ul><li>插入数据：<code>insert [into] &lt;表名&gt; [(列名1,列名2,列名3……)] values (值1,值2,值3……);</code></li><li>更新数据：<code>update &lt;表名&gt; set 列名=新值 where 更新条件;</code></li><li>删除数据：<code>delete from &lt;表名&gt; where 删除条件;</code></li><li>查询数据：<code>select &lt;列名&gt; from &lt;表名&gt; [查询条件];</code></li><li>特定条件查询：where不仅支持“where列名=值”这种名等于值的查询形式，对一般的比较运算的运算符都是支持的，如=、&lt;、&gt;、！=等以及一些扩展运算符is[not] null、in、like等，还可以对查询条件使用or和and进行组合查询。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建数据库： &lt;code&gt;CREATE DATABASE &amp;lt;数据库名&amp;gt; [其他选项]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用数据库： &lt;code&gt;USE &amp;lt;数据库名&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改数据库： &lt;code&gt;ALTER DATABASE &amp;lt;数据库名&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除数据库： &lt;code&gt;DROP DATABASE &amp;lt;数据库名&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://SkyHive.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>关于TCP</title>
    <link href="http://SkyHive.github.io/2017/04/04/%E5%85%B3%E4%BA%8ETCP/"/>
    <id>http://SkyHive.github.io/2017/04/04/关于TCP/</id>
    <published>2017-04-04T04:34:26.000Z</published>
    <updated>2017-04-07T04:40:23.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>互联网协议族（Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP协议集。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（TCP/IP Protocol Stack）</p></blockquote><a id="more"></a><p>以上来自维基百科，我们知道TCP/IP协议族是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大的集合。其中包含了ARP、UDP、ICMP（互联网消息控制管理协议）等协议，它将软件的通信过程抽象化为四个抽象层（应用层、传输层、网络层和物理层），类似于简化的OSI七层。</p><p>在数据传输方面，早期研发提出两种传输方式——面向连接的传输和非面向连接的传输，经过后来长期的发展，提出面向连接的ISO组织将非面向连接的传输纳入自己麾下，就是现在的UDP。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP建立连接的过程——TCP的三次握手"><a href="#TCP建立连接的过程——TCP的三次握手" class="headerlink" title="TCP建立连接的过程——TCP的三次握手"></a>TCP建立连接的过程——TCP的三次握手</h4><p>首先，源向目的发送一个TCP同步请求（syn包）；目的收到后向源发一个TCP回应（offer包），这里面包含了syn+ack信息，此时处于半打开会话状态，存在巨大的安全隐患；源收到目的的回应后向目的发送一个TCP确认包（ack包），就此处于全打开会话状态，TCP连接建立完成。</p><h4 id="TCP序列号和确认号"><a href="#TCP序列号和确认号" class="headerlink" title="TCP序列号和确认号"></a>TCP序列号和确认号</h4><p>TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收（发送序列号是当前的发包情况，确认号是渴望的发包情况）。</p><p>例如在握手的时候，源向目的发送syn包，seq=x；目的会给源一个回应，seq=y，ack=x+1；源收到了之后给目的回一个确认包，ack=y+1。<br><img src="http://old5ws7lp.bkt.clouddn.com/images/三次握手.png"></p><h4 id="TCP划窗"><a href="#TCP划窗" class="headerlink" title="TCP划窗"></a>TCP划窗</h4><p>TCP协议通过划窗机制来对流量进行控制管理，接收端通过发送确认号告诉发送端自己获包的情况，接收端通过三次发包后了解接收端的网络吞吐能力，然后稳定发包。</p><h4 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h4><p>TCP包超时未响应后进行重传，一个包最多重传16次，无法处理后连接断开重连，三次失败后无法进行连接</p><p><strong><em>以上均为自己极浅的理解，详细内容还请移步至Google</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;互联网协议族（Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP协议集。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（TCP/IP Protocol Stack）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Network" scheme="http://SkyHive.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>解决配置完七牛后无法Deploy到gihub</title>
    <link href="http://SkyHive.github.io/2017/02/14/%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E5%AE%8C%E4%B8%83%E7%89%9B%E5%90%8E%E6%97%A0%E6%B3%95Deploy%E5%88%B0github/"/>
    <id>http://SkyHive.github.io/2017/02/14/解决配置完七牛后无法Deploy到github/</id>
    <published>2017-02-14T15:40:26.000Z</published>
    <updated>2017-02-18T08:41:47.199Z</updated>
    
    <content type="html"><![CDATA[<p>将七牛的插件配置好后我写了上一篇博客试一试效果，结果发现怎么也没部署到github，每次<code>hexo d</code>都会出现<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ERROR </span>Deployer not found: git</div></pre></td></tr></table></figure></p><p>这样的报错，Google了半天都没有找到解决的办法，最后在找到了github上的一条issue，终于发现了解决办法：<strong>只要将配置文件_config.yml中plugins的那段给注释掉</strong>就OK了，即<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#plugins:</span></div><div class="line"><span class="meta">#- hexo-qiniu-sync</span></div></pre></td></tr></table></figure></p><p>还是希望开发者能早点修改文档吧，不然还真的挺容易出事，不过说一句，我的Hexo是3.2.2的版本的，不知道2.x版本会不会出现类似的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将七牛的插件配置好后我写了上一篇博客试一试效果，结果发现怎么也没部署到github，每次&lt;code&gt;hexo d&lt;/code&gt;都会出现&lt;br&gt;&lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="Blog" scheme="http://SkyHive.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭配七牛存储图片等媒体资源</title>
    <link href="http://SkyHive.github.io/2017/02/14/Hexo%E6%90%AD%E9%85%8D%E4%B8%83%E7%89%9B%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E7%AD%89%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90/"/>
    <id>http://SkyHive.github.io/2017/02/14/Hexo搭配七牛存储图片等媒体资源/</id>
    <published>2017-02-14T14:19:40.000Z</published>
    <updated>2017-02-14T15:07:59.170Z</updated>
    
    <content type="html"><![CDATA[<p>今天把博客的图片存储搞了一下，利用的七牛存储，相对来说还是比较简单，但是为了测试成功与否就只好写这篇博客了。<br>七牛 是一个云存储服务商，注册并实名认证之后后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。如果想要注册可以<a href="https://portal.qiniu.com/signup?code=3lnfyn5xmh93m" target="_blank" rel="external">点击这里</a>，这样可以为我增加每月5GB的容量。<br><a id="more"></a><br>注册完成之后就可以进行创建空间了，注意我们添加的资源为<strong>对象存储</strong>，访问控制为<strong>公开空间</strong></p><img src="http://old5ws7lp.bkt.clouddn.com/images/qiniu_create.png"><img src="http://old5ws7lp.bkt.clouddn.com/images/qiniu_set.png"><p>然后点击右上角进入<strong>密钥管理</strong>，复制当前使用的AK和SK，配置的时候会用得到<br>下面我们会用到一个叫做的<a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="external">hexo-qiniu-sync</a>的插件，首先在hexo主目录下安装：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> hexo-qiniu-<span class="keyword">sync</span> - -<span class="keyword">save</span></div></pre></td></tr></table></figure></p><p>然后把配置信息添加到_config.yml中<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">plugins:</span></div><div class="line">  - hexo-qiniu-sync</div><div class="line"></div><div class="line"><span class="meta">#七牛云存储设置</span></div><div class="line"><span class="meta">##offline       是否离线. 离线状态将使用本地地址渲染</span></div><div class="line"><span class="meta">##sync          是否同步</span></div><div class="line"><span class="meta">##bucket        空间名称.</span></div><div class="line"><span class="meta">##access_key    上传密钥AccessKey</span></div><div class="line"><span class="meta">##secret_key    上传密钥SecretKey</span></div><div class="line"><span class="meta">##secret_file   秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可</span></div><div class="line"><span class="meta">##dirPrefix     上传的资源子目录前缀.如设置，需与urlPrefix同步 </span></div><div class="line"><span class="meta">##urlPrefix     外链前缀.</span></div><div class="line"><span class="meta">##up_host      上传服务器路径,如选择华北区域的话配置为http:<span class="comment">//up-z1.qiniu.com</span></span></div><div class="line"><span class="meta">##local_dir     本地目录.</span></div><div class="line"><span class="meta">##update_exist  是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)</span></div><div class="line"><span class="meta">##image/js/css  子参数folder为不同静态资源种类的目录名称，一般不需要改动</span></div><div class="line"><span class="meta">##image.extend  这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http:<span class="comment">//developer.qiniu.com/docs/v6/api/reference/fop/image/ </span></span></div><div class="line"><span class="meta">##              可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图</span></div><div class="line"><span class="symbol">qiniu:</span></div><div class="line"><span class="symbol">  offline:</span> false</div><div class="line"><span class="symbol">  sync:</span> true</div><div class="line"><span class="symbol">  bucket:</span> bucket_name</div><div class="line"><span class="symbol">  secret_file:</span> sec/qn.json or C:</div><div class="line"><span class="symbol">  access_key:</span> AccessKey</div><div class="line"><span class="symbol">  secret_key:</span> SecretKey</div><div class="line"><span class="symbol">  dirPrefix:</span> static</div><div class="line"><span class="symbol">  urlPrefix:</span> http:<span class="comment">//bucket_name.qiniudn.com/static</span></div><div class="line"><span class="symbol">  up_host:</span> http:<span class="comment">//upload.qiniu.com</span></div><div class="line"><span class="symbol">  local_dir:</span> static</div><div class="line"><span class="symbol">  update_exist:</span> true</div><div class="line"><span class="symbol">  image:</span> </div><div class="line"><span class="symbol">    folder:</span> images</div><div class="line"><span class="symbol">    extend:</span> </div><div class="line"><span class="symbol">  js:</span></div><div class="line"><span class="symbol">    folder:</span> js</div><div class="line"><span class="symbol">  css:</span></div><div class="line"><span class="symbol">    folder:</span> css</div></pre></td></tr></table></figure></p><p>其中各个参数在插件的<a href="https://github.com/gyk001/hexo-qiniu-sync/blob/master/README.md" target="_blank" rel="external">README文件</a>中都有详细的介绍，按照github上的教程一步一步来是很简单的。</p><p>然后在hexo主目录下创建本地目录（该目录要和配置中local_dir参数保持一致），然后创建iamges、js、css子目录，这样基本的配置就完成了</p><p>下面就可以在你的文章中试着插入图片了，比如你想引用在你/local_dir/images/下的图片1.png<br><figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">qnimg</span> 1.png %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure></p><p>更高级的用法请参考github上的说明。</p><p>下面进行同步<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">hexo qiniu s</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天把博客的图片存储搞了一下，利用的七牛存储，相对来说还是比较简单，但是为了测试成功与否就只好写这篇博客了。&lt;br&gt;七牛 是一个云存储服务商，注册并实名认证之后后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。如果想要注册可以&lt;a href=&quot;https://portal.qiniu.com/signup?code=3lnfyn5xmh93m&quot;&gt;点击这里&lt;/a&gt;，这样可以为我增加每月5GB的容量。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://SkyHive.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Ubuntu系统设置打不开</title>
    <link href="http://SkyHive.github.io/2017/02/14/%E8%A7%A3%E5%86%B3Ubuntu%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E6%89%93%E4%B8%8D%E5%BC%80/"/>
    <id>http://SkyHive.github.io/2017/02/14/解决Ubuntu系统设置打不开/</id>
    <published>2017-02-14T11:23:32.000Z</published>
    <updated>2017-02-14T11:25:34.074Z</updated>
    
    <content type="html"><![CDATA[<p>今天把Ubuntu从16.04更新到16.10之后卸载了些软件，之后蛋疼的发现系统设置打不开了，真是欲哭无泪。去网上搜了下发现是我之前由于卸载了iBus导致的，虽然我不懂为什么iBus和Ubuntu之间的关系为什么会如此紧密，但是既然发生了这种事情我也很绝望啊，只能按照网上的方法<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install ubuntu-desktop         <span class="comment">#这个会把Ubuntu预装的软件office还有Amazon什么的装回来，装完自己再慢慢卸载吧</span></div></pre></td></tr></table></figure></p><p>或者他也提供了一次性的安装办法<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install ibus-pinyin unity-control-<span class="built_in">center</span> unity-control-<span class="built_in">center</span>-signon webaccounts-extension-common xul-ext-webaccounts</div></pre></td></tr></table></figure></p><p>但是我眉头一皱，发现事情并不简单，我继续搜了下去，也有很多人遇到这种问题，发现还有更简单的办法<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install gnome-control-<span class="built_in">center</span>           #如果系统设置打不开，请重新安装gnome-control-<span class="built_in">center</span></div><div class="line">sudo apt-<span class="built_in">get</span> install unity-control-<span class="built_in">center</span>           #如果设置里只有很少的几个图标请重新安装unity-control-<span class="built_in">center</span></div></pre></td></tr></table></figure></p><p>当然上面两个方法并没有尝试过，我也无从得知导致我系统设置打不开的原因是不是卸载了iBus</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天把Ubuntu从16.04更新到16.10之后卸载了些软件，之后蛋疼的发现系统设置打不开了，真是欲哭无泪。去网上搜了下发现是我之前由于卸载了iBus导致的，虽然我不懂为什么iBus和Ubuntu之间的关系为什么会如此紧密，但是既然发生了这种事情我也很绝望啊，只能按照网上
      
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo的建站之旅</title>
    <link href="http://SkyHive.github.io/2017/02/14/Hexo%E7%9A%84%E5%BB%BA%E7%AB%99%E4%B9%8B%E6%97%85/"/>
    <id>http://SkyHive.github.io/2017/02/14/Hexo的建站之旅/</id>
    <published>2017-02-14T09:54:35.000Z</published>
    <updated>2017-07-14T08:46:36.962Z</updated>
    
    <content type="html"><![CDATA[<p> 这几天觉得wordpress作为博客实在是太臃肿了，而且访问的后台以及更新都极其的慢，以至于想把博客迁到Hexo上去。<br>Hexo 是个简洁快速且高效的博客框架，是个台湾的学生写的，所以对中文还是挺友好的，我们用起来也很方便，而且Hexo仅依赖node，易于安装。<br>首先准备的工具仅需要node.js,git即可，在ubuntu上安装这两样工具也是极其简单：<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get <span class="keyword">install</span> nodejs</div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> npm</div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> nodejs-legacy #由于ubuntu仓库中本来就有一个node，所以在ubuntu下nodejs命令不是node而是nodejs，但是安装nodejs-legacy后就可以解决这个问题了，具体为什么我也不知道</div><div class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> git</div></pre></td></tr></table></figure></p><p>下面开始安装Hexo:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-<span class="keyword">cli</span></div></pre></td></tr></table></figure></p><p>安装完成后就可以部署博客了，根据Hexo官网上的步骤：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init <span class="params">&lt;floder&gt;</span></div><div class="line">cd <span class="params">&lt;floder&gt;</span></div><div class="line">sudo nmp install<span class="meta">#安装依赖包</span></div></pre></td></tr></table></figure></p><p>下面可以安装一些插件，大家可以根据不同的需要安装，网上都有教程，我就不赘述了，但是有一个插件是需要安装的：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> hexo-deployer-git --save <span class="comment">#这是一个可以自动部署到github上的插件</span></div></pre></td></tr></table></figure></p><p>接下来的配置可以参考官网上给出的配置详解，自己根据需要去手动配置，至于主题可以在Hexo提供的<a href="https://hexo.io/themes/" target="_blank" rel="external">网站</a>选择，然后从github上clone到themes下。配置完成后可以执行一下命令：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo <span class="keyword">generate</span> #这个命令用于部署网页的静态文件，每次修改后都应该首先执行这条命令</div></pre></td></tr></table></figure></p><p>如果想先预览网页效果的话，可以执行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">hexo</span> <span class="selector-tag">s</span><span class="selector-id">#s</span>即<span class="selector-tag">server</span>,执行完成后可以在<span class="selector-tag">localhost</span><span class="selector-pseudo">:4000</span>下预览</div></pre></td></tr></table></figure></p><p>下面需要部署github端了，首先在你的github上创建一个仓库，仓库名必须为”username.github.io”，其中”username”为你的用户名，创建完成后写一个README使github自动帮你创建github pages</p><p>接着在你的终端配置git:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user<span class="selector-class">.name</span> <span class="string">"你github的username"</span></div><div class="line">git config --global user<span class="selector-class">.email</span> <span class="string">"你的github邮箱"</span></div></pre></td></tr></table></figure></p><p>然后生成密钥：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你的邮箱"</span></div></pre></td></tr></table></figure></p><p>回车确认，输入密码再确认，然后前往提示信息的目录下会有两个文件，其中id_rsa是私钥，id_rsa.pub是公钥<br>然后添加生成的key：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-<span class="keyword">add</span><span class="bash"> id_rsa</span></div></pre></td></tr></table></figure></p><p>然后将id_rsa.pub中的内容（除去最后你邮箱的那部分）复制下来，在你github主页中找到settings中的SSH Keys，将复制的公钥添加进去，title随便取个名字就好。<br>最后我们只要把Hexo生产的网页部署到github上就可以了，来到我们创建的博客目录，打开配置文件，在Deployment中配置：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># Deployment</span></div><div class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></div><div class="line"><span class="symbol">deploy:</span> </div><div class="line"><span class="symbol">  type:</span> git</div><div class="line"><span class="symbol">  repository:</span> https:<span class="comment">//github.com/username/username.github.io</span></div><div class="line"><span class="symbol">  branch:</span> master</div></pre></td></tr></table></figure></p><p>同样的，”username”是你github的用户名<br>然后在博客根目录执行：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">generate</span> </div><div class="line">hexo deploy#部署博客到github</div></pre></td></tr></table></figure></p><p>输出一下信息便说明我们部署成功：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">INFO</span> Deploy do<span class="symbol">ne:gi</span><span class="built_in">t</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这几天觉得wordpress作为博客实在是太臃肿了，而且访问的后台以及更新都极其的慢，以至于想把博客迁到Hexo上去。&lt;br&gt;Hexo 是个简洁快速且高效的博客框架，是个台湾的学生写的，所以对中文还是挺友好的，我们用起来也很方便，而且Hexo仅依赖node，易于安装。&lt;br&gt;首先准备的工具仅需要node.js,git即可，在ubuntu上安装这两样工具也是极其简单：&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://SkyHive.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次Arch的安装经历</title>
    <link href="http://SkyHive.github.io/2017/02/13/%E8%AE%B0%E4%B8%80%E6%AC%A1Arch%E7%9A%84%E5%AE%89%E8%A3%85%E7%BB%8F%E5%8E%86/"/>
    <id>http://SkyHive.github.io/2017/02/13/记一次Arch的安装经历/</id>
    <published>2017-02-13T09:57:58.000Z</published>
    <updated>2017-07-14T08:43:52.030Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于听信了别人的“谗言”，心血来潮想试一试Arch，所以便准备在虚拟机上装一个Arch来看看效果，也算是一次艰难的装系统之路了吧。</p><p>那么下面打开虚拟机，进入安装界面：</p><p>首先是分区，Arch给我们提供了一个很好的分区交互工具cfdisk<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">cfdisk</span>        <span class="comment">#使用cfdisk进行分区</span></div></pre></td></tr></table></figure></p><a id="more"></a><p><em>选择第二个dos类型</em>，这是将sda设置成MBR类型的分区，之前在遇到这个选项的时候，我下意识的选了第一个GPT，然后还去google了一下，说GPT很好,就使用这个吧，结果后面分区的时候和教程不一样，装好系统后怎么也进不去。</p><p>接下来你可以把整个硬盘设置成一个根分区或者分成一个根分区和一个boot分区。<em>如果设置成一个根分区记得要把那个分区设置bootable；如果是一个根分区和一个boot分区记得要把boot分区设置bootable。</em></p><p>退出cfdisk后格式化新设置的分区<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsblk       <span class="comment">#查看存储设备的状态，sda1、sda2这样的就是我们刚刚分出来的</span></div><div class="line">mkfs.ext4 <span class="regexp">/dev/</span>sda1</div><div class="line">mkfs.ext4 <span class="regexp">/dev/</span>sda2         <span class="comment">#将根分区和boot分区格式化成ext4格式</span></div></pre></td></tr></table></figure></p><p>然后就可以进行挂载了<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mount <span class="regexp">/dev/</span>sda2 <span class="regexp">/mnt           #将根分区挂载到/m</span>nt</div><div class="line">mkdir <span class="regexp">/mnt/</span>boot         <span class="comment">#为boot分区创建挂载点</span></div><div class="line">mount <span class="regexp">/dev/</span>sda1 <span class="regexp">/mnt/</span>boot</div></pre></td></tr></table></figure></p><p>接着修改软件镜像源<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /etc/pacman.d        <span class="comment">#镜像源文件在这个目录下</span></div><div class="line"><span class="comment">#我们需要将China源放到文件头的位置，下面先将这段源提取到temp这个文件里</span></div><div class="line"><span class="keyword">grep</span> -A <span class="number">1</span> <span class="string">'##.*China'</span> mirrorlist|<span class="keyword">grep</span> -v <span class="string">'\-\-'</span> &gt; temp</div><div class="line"><span class="comment">#然后将mirrorlist的内容添加到temp的最后面</span></div><div class="line">cat mirrorlist &gt;&gt; temp</div><div class="line">mv temp mirrorlist         <span class="comment">#temp替换mirrorlist</span></div></pre></td></tr></table></figure></p><p>然后刷新软件仓库列表就可以开始安装了<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pacman -Syy         <span class="meta">#刷新软件仓库列表</span></div><div class="line">pacstrap -i /mnt <span class="keyword">base</span> <span class="keyword">base</span>-devel        <span class="meta">#安装系统</span></div></pre></td></tr></table></figure></p><p>接下来需要生成一个叫fstab的配置文件，在开机时候会由mount命令读取并挂载其中的分区。在安装完基本系统之后，就可以将fstab信息写入新安装的系统中了。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">genfstab -U -p /mnt &gt;&gt; <span class="regexp">/mnt/etc</span><span class="regexp">/fstab</span></div><div class="line">nano /mnt<span class="regexp">/etc/fstab</span>         <span class="comment">#确认fstab文件真的生成了</span></div></pre></td></tr></table></figure></p><p>下面我们就可以进入新系统进行配置了<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arch-chroot /mnt <span class="meta-keyword">/bin/</span>bash</div><div class="line">passwd          <span class="meta">#设置root密码</span></div><div class="line">echo 主机名 &gt; <span class="meta-keyword">/etc/</span>hostname         <span class="meta">#设置主机名</span></div></pre></td></tr></table></figure></p><p>然后配置区域<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nano <span class="regexp">/etc/</span>locale.gen</div></pre></td></tr></table></figure></p><p>将<code>en_US.UTF-8</code>、<code>zh_CN.UTF-8</code>、<code>zh_TW.UTF-8</code>的注释去掉，然后按Ctrl+x保存，退出，使用<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">locale-gen</span></div></pre></td></tr></table></figure></p><p>生成区域，然后设置locale.conf文件<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo LANG=en_us.UTF-<span class="number">8</span> &gt; <span class="regexp">/etc/</span>locale.conf<span class="comment">#如果在终端下使用中会出现乱码，可以装fbterm来解决</span></div></pre></td></tr></table></figure></p><p>下面配置时区<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -sf <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc<span class="regexp">/localtime</span></div></pre></td></tr></table></figure></p><p>安装引导工具Grub<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pacman -S grub</div><div class="line">grub-install --recheck <span class="meta-keyword">/dev/</span>sda1        <span class="meta">#将grub写入系统，没有提示错误说明写入成功</span></div><div class="line">grub-mkconfig -o <span class="meta-keyword">/boot/</span>grub/grub.cfg        <span class="meta">#生成配置文件</span></div></pre></td></tr></table></figure></p><p>配置一下网络<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> dhcpcd.service</div></pre></td></tr></table></figure></p><p>到现在为止，系统基本上配置好了，现在退出新系统，卸载挂载的分区，然后重启虚拟机<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">exit</span></div><div class="line">umount -R /mnt</div><div class="line">reboot</div></pre></td></tr></table></figure></p><p>剩下来的安装图形化界面和美化的步骤可以自行google。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近由于听信了别人的“谗言”，心血来潮想试一试Arch，所以便准备在虚拟机上装一个Arch来看看效果，也算是一次艰难的装系统之路了吧。&lt;/p&gt;
&lt;p&gt;那么下面打开虚拟机，进入安装界面：&lt;/p&gt;
&lt;p&gt;首先是分区，Arch给我们提供了一个很好的分区交互工具cfdisk&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;cfdisk&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;#使用cfdisk进行分区&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://SkyHive.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>
