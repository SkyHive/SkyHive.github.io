<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Ubuntu循环登录界面]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%85%B3%E4%BA%8EUbuntu%E5%BE%AA%E7%8E%AF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[其实事情的起因很奇怪，前两天一直想升级Ubuntu 18.04，不知道为什么17.10用着怪怪的，但是18.04又要到4月26号才发布，没有办法了只能Beta 2先用着试试了。 然后就是一顿正常的操作 从Ubuntu 17.10 升级到 18.04 Beta 212345# 先将当前系统更新sudo apt updatesudo apt upgrade#然后升级系统sudo do-release-upgrade -d 然后就让系统自己去下载安装了，不过中途我在终端提示中看到了某个什么东西不可用，当然我也没有在意，估计更新到了正式版系统就没事了吧，结果这就埋下了伏笔。 卡在了启动界面没错，就是那个带着Ubuntu logo，然后logo下面还有几个小点点的那个界面，卡的死死的。ESC之后显示的状态应该是这样的 1[Started] Gnome Display Manage 然后我当机立断的去Google了一下，不知道在哪里看到了一个答案是要进Recovery mode修复一下dpkg，做完之后我觉得这并不够，开在启动界面的事情我第一次装Ubuntu也是遇到过，我知道是显卡驱动的问题，然后不知道在哪看到的方法，把我Nvidia驱动给卸载掉了。 第一次装Ubuntu遇到这问题，解决的办法是在Ubuntu 高级选项中，对需要引导的内核按e进行编辑，在 quiet splash那一行后面加上acpi_osi=linux nomodeset，这个是针对N卡的，如果是A卡或者Intel核显有对应的解决办法 Ubuntu Login Loop重启之后确实能度过了logo的那一关，但是新的问题又来了，这次能达到登录的界面，但是输入密码登录之后会黑屏一下又回到登录界面。 这个Ubuntu Login Loop的问题已经不新鲜了，之前每个版本都有人遇到过，而且引起的原因也各不相同，这次我遇到了这个坑就来稍微的总结一下 .Xauthority文件的所有人和所有组变成了root：在你用户的主目录下有一个.Xauthority文件，用ls -la查看一下该文件的所有人和所有组，如果是root的话那么需要将其改为你的登录用户 1sudo chown username:username .Xauthority /tmp权限：用ls -ld查看一下/tmp的权限是否是drwxrwxrwxt，否则就将其权限修改 1sudo chmod a+wt /tmp 当然还有就是显卡驱动惹的祸：网上大部分人都是更新了显卡驱动才一直循环登录界面，而我就比较特殊了，我是卸载了显卡驱动，不过解决办法都是一样，就是重装显卡驱动呗 1234567891011121314151617#完全卸载N卡驱动sudo apt remove --purge nvidia*#关闭图形界面sudo service lightdm stop#禁用nouveau驱动#在/etc/modprobe.d/blacklist.conf中加入如下内容：blacklist nouveauoptions nouveau modeset=0#然后执行sudo update-initramfs -u#安装Nvidia驱动sudo add-apt-repository ppa:xorg-edgers/ppa #添加ppa源sudo add-apt-repository ppa:graphics-drivers/ppa #添加ppa源sudo apt update #更新apt-getsudo apt install nvidia-375#最后别忘了打开图形化界面sudo service lightdm start 由于我的显卡是GTX 960M，参考了一下网友们安装的是375的显卡驱动，等我安装完成后，系统提醒我显卡驱动太低级需要升级，没有办法还是升到了390，然后重启一下，输入密码又回到了熟悉的图形化界面 写在最后当然login loop的原因不止这些，有时候/etc/profile中改了或者加了些东西导致这些古怪的问题，所以我们需要对症下药。正确的做法是要先去查看主目录下.xsession-errors日志的报错信息，从而去判断原因。 什么？你问我图形化界面进不去怎么做那么多操作？图形化进不去，还有命令行啊，我的图形化是tty1，以上操作都是在tty5中进行的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初探Django需要注意的事项]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%88%9D%E6%8E%A2Django%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[更改默认数据库为MySQLDjango使用的默认数据库是SQLite3，如果习惯使用的是SQLite的用户就可以不必更换数据库。 更换数据库的话在settings.py文件中DATABASES选项中进行更改12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': '项目对应的数据库名称', 'USER': '登录mysql的帐户', 'PASSWORD': '登录mysql的密码', 'HOST': '127.0.0.1', #由于是在本地开发，所以是127.0.0.1 'PORT': '3306' #这里mysql使用的是默认的3306端口 &#125;&#125; 设置Templates的路径在settings.py文件中的TEMPLATES选项中进行设置 1'DIRS': [os.path.join(BASE_DIR, 'templates')] 其中BASE_DIR是项目的绝对路径，设置过Templates路径之后Django会在改路径下的templates文件夹下搜索对应的html文件。 设置中文settings.py最后有个选项为LANGUAGE_CODE，这个选项是设置Django语言的。Django为我们提供了很多自带的应用，如果习惯了看英文的话可以不用设置，直接使用默认的英语，如果英语看着膈应的话，可以设置为中文zh-hans或者zh_Hans 添加创建的应用当你新建应用之后要记得在settings.py中的INSTALLED_APPS选项中添加新建的应用——直接在最后一行添加新建的应用名就好了。 修改数据默认显示名称在创建的数据类下面添加一个方法，根据Python的版本进行选择 123python 2.7 : __unicode__(self)python 3 : __str__(self)然后在方法中返回self.var #var是类中数据中用来显示数据的变量 Tamplates 过滤器这个过滤器其实可以说就是Linux下的管道符|，Linux玩的转的人对这个一定不会陌生，过滤器的基本形式就像这样 1&#123;&#123;var | filter&#125;&#125; 有些过滤器会跟有参数，过滤器的参数都是跟随冒号，例如 1&#123;&#123;var | default:'0'&#125;&#125; #为变量var设置默认值0]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[配置ssh免密登录遇到的坑]]></title>
    <url>%2F2017%2F12%2F08%2F%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近在学校做一个云计算大赛，需要搭建一个hadoop的平台（一共四台服务器，这是一个怎样的hadoop啊），搭建的中途遇到一个小插曲。由于需要四台服务器能够互相免密访问，我们需要将四台服务器的公钥互相上传到各个机器，首先运行1ssh-keygen -t rsa 然后一直回车，最后会在你主目录下生成一个.ssh目录，其中的id_rsa是你的密钥，id_rsa.pub是你要上传的公钥，known_hosts是你连接过的主机的信息 我们需要在.ssh目录下建立一个authorized_keys文件，将各个主机的公钥信息存储在该文件下，然后各个主机就可以通过ssh免密登录了，至于具体的原理，大家可以网上自行科普一下，无非是一些加密解密的过程。 然而就在我以为万无一失的时候，造化弄人，我不管怎么搞都需要输密码，试过改ssh的配置文件也无法解决，最后google到一个解决方法，说是目录的和文件的权限问题，.ssh目录的权限必须得是700，而文件authorized_keys的权限必须是644，而我当时是664,这才导致无法进行免密登录，这里大家需要注意一下权限的问题，即使权限放大了也是不行的！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop简介]]></title>
    <url>%2F2017%2F11%2F17%2FHadoop%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Hadoop 介绍Hadoop是Apache组织的一个分布式计算框架（java语言），其最核心的设计就是：HDFS 和MapReduce，HDFS实现存储，MapReduce实现原理分析处理。 HDFS文件系统HDFS（Hadoop Distributed File System）是一个高度容错的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合那些有着超大数据集的应用程序。 设计特点 大数据文件，适合大文件或者一堆大数据文件 文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算机上 流式数据访问，一次写入多次读写，和传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化只能在文件末尾添加 廉价硬件 备份，为防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其他某几个主机上 Master / Slave架构一个HDFS集群是有一个Namenode和一定数目的Datanode组成。Namenode作为中心服务器负责管理文件系统的namespace和客户端对文件的访问，Datanode在集群中负责管理结点上他们附带的存储。在内部，一个文件其实分成一个或多个block，这些block存储在Datanode集合里。Namenode执行文件系统的namespace操作，如打开、关闭、重命名等，同时决定 block到具体Datanode结点的映射。Datanode在Namenode的指挥下进行block的创建、删除和复制。 HDFS的一些关键元素 Block：将文件分块，通常为64M。 NameNode：保存整个文件系统的目录信息、文件信息及分块信息，由唯一一台主机专门保存。（2.0版本后增加备份） DataNode：用于存储Block文件。 NameNode全权管理数据块的复制，它周期性地从集群中的每个DataNode接受心跳信号和块状态报告（BlockReport）。结合艘到心跳信号以为这该DataNode工作正常，块状态报告包含了一个该DataNode上所有数据块的列表。 MapReduce文件系统MapReduce是一种编程模型，用于大规模数据的并行运算。MapReduce分成两个部分：Map（映射）和Reduce（归纳）。当你向MapReduce框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map任务，然后分配到不同的节点上去执行，每一个Map任务处理输入数据中的一部分，当Map任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce任务的输入数据。Reduce任务的主要目标就是把前面若干个Map的输出汇总并输出。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2017%2F10%2F15%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列队列是一种可以实现先进先出(first in first out,FIFO)的存储结构。与栈不一样的是，队列规定只在一端进行插入操作，在另一端进行删除操作。允许插入的一端叫做队尾(rear)，允许删除的一端叫做队首(front)。 分类 链式队列：用链表实现。 静态队列：用数组实现。(为了解决假溢出现象，静态队列通常都必须是循环队列) 循环队列 参数：front、rear rear所指的单元始终为空 队列初始化：front和rear的值都是0。 队列非空：front指向队列的第一个元素；rear指向队列的最后一个有效元素的下一个元素。 队列空：front和rear值相等，但不一定是0。 算法解析1.入队：将值存入rear所代表的位置r 错误写法：r=r+1 正确写法：r=(r+1)%数组长度 2.出队：f=(f+1)%数组长度 3.判断循环队列是否为空 rear = front 4.判断循环队列是否已满 多增加一个参数标志满或者空（一般不用此方式） 少用一个元素：如果(r+1)%数组长度==f表示循环队列已满 代码实现1.队列数据建构 123456typedef struct queue &#123; int *p; int front; int rear; int maxsize;&#125;Queue; 2.初始化队列 123456789void CreateQueue(Queue *Q,int maxsize)&#123; Q-&gt;p = (int*)malloc(sizeof(int)*maxsize); if(!Q-&gt;p)&#123; printf("Memory allocation failure!"); exit(-1); &#125; Q-&gt;front = Q-&gt;rear; Q-&gt;maxize = maxsize;&#125; 3.判断循环队列是否为满 123456int isFull(Queue *Q)&#123; if ((Q-&gt;rear+1)%Q-&gt;maxsize == Q-&gt;front) return 1; else return 0;&#125; 4.判断循环队列是否为空 123456int isEmpty(Queue *Q)&#123; if(Q-&gt;rear == Q-&gt;front) return 1; else return 0;&#125; 5.入队操作 12345678910void Enter(Queue *Q,int val)&#123; if (isFull(Q))&#123; printf("The queue is full!"); return; &#125; else&#123; Q-&gt;p[Q-&gt;rear] = val; Q-&gt;rear = (Q-&gt;rear+1)%Q-&gt;maxsize; &#125;&#125; 6.出队操作 123456789void Delete(Queue *Q,int *val)&#123; if(isEmpty(Q)) return 0; else&#123; *val = Q-&gt;p[Q-&gt;front]; Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxszie; printf("Get out of the queue successfully!"); &#125;&#125; 7.遍历操作 123456789void Traverse(Queue *Q)&#123; int i = Q-&gt;front; printf("The items in queue are:\n"); while(i%Q-&gt;maxsize!=Q-&gt;rear)&#123; printf("%d",Q-&gt;p[i]); i=(i+1)%Q-&gt;maxsize; &#125; printf("\n");&#125; 链式队列链式队列实现和链式栈相差不多，只是将删除操作放在了另外一端，有效的解决了顺序队列存储空间不足的缺陷。 代码实现1.队列节点构建 1234typedef struct Node&#123; int data; //数据域 struct Node *next; //指针域&#125;Node; 1234typedef struct&#123; Node *front; Node *rear;&#125;Queue; 2.队列初始化 1234567891011int InitQueue(Queue *Q)&#123; Node *head = (Node*)malloc(sizeof(Node)); if(!head)&#123; printf("Memory allocation failed!\n"); return ; &#125; head-&gt;next = NULL; Q-&gt;rear = Q-&gt;front = head; //front和rear都指向头指针 printf("Init successfully!\n"); return 0;&#125; 3.入队操作 123456789101112int Enter(Queue *Q,int item)&#123; Node *s = (Node*)malloc(sizeof(Node)); if(!s)&#123; printf("Memory allocation failed!\n"); return ; &#125; s-&gt;next = NULL; s-&gt;data = item; Q-&gt;rear-&gt;next = s; Q-&gt;rear = s; return 0;&#125; 4.出队操作 12345678910111213void Delete(Queue *Q,int *item)&#123; if(Q-&gt;front == Q-&gt;rear)&#123; printf("The queue is empty!\n"); return; &#125; Node *p; p = Q-&gt;front-&gt;next; //先将要出栈的节点存在P中 Q-&gt;front-&gt;next = p-&gt;next; //重新构造队头元素的后继 *item = p-&gt;data; //保存出队的数据； if(Q-&gt;rear == p) //判断删除的节点是否为队尾元素 Q-&gt;rear = Q-&gt;front; free(p);&#125; 5.遍历元素 1234567891011void Traverse(Queue *Q)&#123; if(Q-&gt;front == Q-&gt;rear)&#123; printf("The queue is empty!\n"); &#125; Node *p = Q-&gt;front-&gt;next; while(p)&#123; printf("%d",p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2017%2F10%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈是一种先进后出的线性数据结构，规定只允许在一端进行插入和删除元素的操作。其中进栈操作又叫做压栈（Push），出栈操作又叫做弹出（Pop）。允许进行操作的一端叫做栈顶（top），另一端叫做栈底（base）。 分类 顺序栈：数组实现 链式栈：链表实现 代码实现 顺序栈 1.构建栈的结构 12345#define MAXSIZE 1024 //定义栈的空间大小typedef struct stack&#123; int data[MAXSIZE]; int top;&#125;Stack; 2.初始化 12345678910111213Stack *Init()&#123; Stack stack; stack = (Stack*)malloc(sizeof(Stack)); if(!stack)&#123; printf("Memory allocation failed!"); return NULL; &#125; else&#123; stack-&gt;top = -1; //C语言数组下标从0开始 printf("Init successfully!"); return stack; &#125;&#125; 3.判断栈是否为空 1234567int isEmpty(Stack* stack)&#123; if(stack-&gt;top == -1)&#123; printf("The stack is empty!"); return 1; &#125; return 0;&#125; 4.判断栈是否满 1234567int isFull(Stack* stack)&#123; if(stack-&gt;top == MAXSIZE-1)&#123; printf("The satck is full!"); return 1; &#125; return 0;&#125; 5.进栈操作（Push） 123456void Push(Stack* stack,int item)&#123; if(isFull(stack))&#123; return; &#125; stack-&gt;data[++stack-&gt;top] = item;&#125; 入站操作先移动Top，再压入元素 6.出栈操作（Pop） 123456int Pop(Stack* stack)&#123; if(isEmpty(stack))&#123; return -99; &#125; return stack-&gt;data[stack-&gt;top--]; //返回被弹出的元素&#125; 7.遍历操作 123456void Traverse(Stack* satck)&#123; printf("The items in the stack are:\n"); for (int i=stack-&gt;top;i &gt;= 0;i--)&#123; printf ("%d\n",stack-&gt;data[i]); &#125;&#125; 链式栈 1.构建栈的结构 1234typedef struct node&#123; int data; struct node* next;&#125;Node; 2.初始化栈 12345678910111213Node* Init()&#123; Node* s; s = (Node*)malloc(sizeof(Node)); if(!s)&#123; printf("Memory allocation failed!"); return NULL; &#125; else&#123; printf("Init successfully!"); s-&gt;next = NULL; return s; &#125;&#125; 3.判断栈是否为空 123int isEmpty(Node* s)&#123; return (s-&gt;next == NULL);&#125; 4.进栈操作 1234567891011void Push(Node* s,int item)&#123; Node* node; //为插入的元素构建一个节点 node = (Node*)malloc(sizeof(Node)); if(!node)&#123; printf("Memory allocation failed!"); return NULL; &#125; node-&gt;data = item; node-&gt;next = s-&gt;next; //这里写成node-&gt;next = NULL应该也可以吧 s-&gt;next = node;&#125; 5.出栈操作 12345678910111213int Pop(Node* s)&#123; Node* Top; int data; if(isEmpty(s))&#123; printf("The stack is empty!"); return -99; &#125; Top = s-&gt;next; s-&gt;next = Top-&gt;next; data = Top-&gt;data; free(Top); return data;&#125; 6.遍历操作 123456789void Traverse(Node* s)&#123; printf("The items in the stack are:\n"); Node* p; p = s; while (p-&gt;next != NULL)&#123; printf("%d\n",p-&gt;data); p = p-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的Shadowsocks服务]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Shadowsocks%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[最近一直想自己搭一个Shadowsocks服务，并且利用服务器学习一些技术知识，但是国内的服务器实在是贵得很啊，像我这种苦逼大学生根本玩不起，无奈之下只好各种google百度，最后找到了一些国外的VPS资源 BandwagonHost(搬瓦工VPS)：据观察搬瓦工这个VPS还是算计比较便宜的，年付20刀，平均下来每个月只有1.6刀，而且套餐很良心很良心,512MB的内存，10GB的SSD，1TB的流量是不是比国内很多主机都划算的很。 Vultr:同样也是SSD VPS,这个套餐看起来也还是很不错的，只不过每月两刀的套餐总是能被抢空。 Digital Ocean：也是我目前正在使用的，大家可以点击此链接注册，通过这个优惠链接注册的小伙伴们会直接获得10美刀的额度在你的账户余额里。而且他的这个套餐也是很诱人的，同样的SSD VPS，20G硬盘，每月1TB流量，1G的带宽，只不过这个费用看起来太贵了，一个月需要五美刀。 但是事情有这么简单吗？ 当然没有，鼎鼎大名的gayhub上有个提供给学生的pack，里面有各种东西，有需要者可以根据需要去使用，其中就有Digital Ocean的价值50刀的credit。好了，既然有了这等美差，下面该怎么搞呢？ 既然是给学生用的，那么github肯定要判断你学生的身份，这个时候你需要一个edu邮箱，基本上国内很多大学都会给学生使用edu邮箱的，用你的edu邮箱去注册github；或者有的已经注册过github的怎么办呢，登录帐号后进入setting选项，在右侧的Email中添加一个email地址，然后验证就好了。进入学生包申请页面，点击GET your pack，然后就正常填写信息即可，之后我们就能获得需要的优惠码了。下面我注册Digital Ocean，正常的注册步骤，邮箱注册可以使用任意邮箱；邮箱验证结束之后进入到第二部验证，这一步需要有信用卡或者PayPal之类的(如果你我皆是大穷逼的话，可以和我一样选择使用PayPal，注册一个PayPal再去绑定一张卡即可),选择PayPal验证，然后支付5美刀即可完成验证，第三步是创建一个Droplet，即创建一个VPS，至于配置： 系统根据你的需要去选择 size选最小的$5/mo即可，你要是有钱我也不说什么了 数据中心的话，推荐洛杉矶1号机房吧，至于他们说的什么新加坡，我亲测慢成狗。 之前注册的时候花了5美元，送了10美元，加上优惠码的50美元，一共就有65美元了，实际花费五美元，使用十三个月，是不是物超所值。 VPS创建完之后，Digital Ocean会把IP、账号和密码都发到你的注册邮箱，然后你就可以利用putty或者ssh登录到服务器啦！ 下面就开始搭建我们的Shadowsocks服务： 安装Shadowsocks首先我们要安装Shadowsocks，由于Shadowsocks是用python写的，我们先安装pip123#由于我用的是Ubuntu的系统，其他系统的用户请自行Googleapt-get install python-pippip install shadowsocks 优化Shadowsocks性能按照SS官方Wiki，我们进行优化： 创建local.conf配置文件1vim /etc/sysctl.d/local.conf 进入编辑模式之后输入以下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445# max open filesfs.file-max = 51200# max read buffernet.core.rmem_max = 67108864# max write buffernet.core.wmem_max = 67108864# default read buffernet.core.rmem_default = 65536# default write buffernet.core.wmem_default = 65536# max processor input queuenet.core.netdev_max_backlog = 4096# max backlognet.core.somaxconn = 4096# resist SYN flood attacksnet.ipv4.tcp_syncookies = 1# reuse timewait sockets when safenet.ipv4.tcp_tw_reuse = 1# turn off fast timewait sockets recyclingnet.ipv4.tcp_tw_recycle = 0# short FIN timeoutnet.ipv4.tcp_fin_timeout = 30# short keepalive timenet.ipv4.tcp_keepalive_time = 1200# outbound port rangenet.ipv4.ip_local_port_range = 10000 65000# max SYN backlognet.ipv4.tcp_max_syn_backlog = 4096# max timewait sockets held by system simultaneouslynet.ipv4.tcp_max_tw_buckets = 5000# turn on TCP Fast Open on both client and server sidenet.ipv4.tcp_fastopen = 3# TCP receive buffernet.ipv4.tcp_rmem = 4096 87380 67108864# TCP write buffernet.ipv4.tcp_wmem = 4096 65536 67108864# turn on path MTU discoverynet.ipv4.tcp_mtu_probing = 1# for high-latency networknet.ipv4.tcp_congestion_control = hybla# for low-latency network, use cubic instead# net.ipv4.tcp_congestion_control = cubic 保存退出后，执行以下命令使之生效：1sysctl --system 配置Shadowsocks配置文件在/etc/下创建配置文件：vim /etc/shadowsocks.json然后进行编辑：12345678910&#123; "server":"my_server_ip", "server_port":8388, "local_address":"127.0.0.1", "local_port":1080, "password":"mypassword", "timeout":300, "method":"aes-256-cfb" #这里的加密方式也可以选择其他的类型，自行把握 "fast_open":false&#125; 最后启用Shadowsocks服务端功能1nohup ssserver -c /etc/shadowsocks.json -d start &amp; nohup是把运行日志输出到当前用户主目录下的nohup.out文件中 到这里VPS上的Shadowsocks服务基本上就搭建完毕了，接下来的事情我想大家应该都会做了吧，爬上梯子开始翻墙吧。]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu下PHP验证码不显示问题]]></title>
    <url>%2F2017%2F07%2F14%2F%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8BPHP%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这两天在帮别人写一个注册登录功能的页面，用到了简单的TP框架，但是在我自己的Ubuntu环境下发现验证码出了问题——验证码图片显示不出来。 我将图片单独拉出来，发现错误提示如下：1Call to undefined function imagecreate() 百度一问就找到了答案，原来这是由于没有安装或者开启PHP的GD库导致的，既然这样我只需要安装一下GD库就解决了：1sudo apt-get install php7.0-gd 安装完毕后将Apache服务器重启，如果是Nginx的话，则可用可不用 如果是Windows环境的话，打开PHP安装目录下的php.ini配置文件，找到：1;extension=php_gd2.dll 去掉注释，重启服务就解决了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu下Apache不解析PHP问题]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8BApache%E4%B8%8D%E8%A7%A3%E6%9E%90PHP%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这两天笔者遇到了一个很操蛋的问题——Apache无法解析PHP代码了，之前一直用的挺好的，突然就挂了，然后在网上疯狂的找解决办法，但是大都是php5的版本，而我却是7的版本，我就先顺便把5版本的解决方法贴出来： 修改apache的配置文件httpd.conf在httpd.conf中找到：AddType application/x-gzip .gz .tgz在该行下面添加AddType application/x-httpd-php .php 再找继续找到：DirectoryIndex index.html，把此行修改成DirectoryIndex index.html index.htm index.php 再找到：#ServerName www.example.com:80改成ServerName localhost:80 然而Ubuntu下的Apache并没有httpd.conf这个配置文件，而是通过一个apache2.conf来引用每个部分的配置文件，这样在一个配置包里找到那一句配置也并不简单，而且我还没有找到。。。 不过皇天不负有心人，终于是找到了解决办法：1sudo apt-get install libapache2-mod-php 这一步安装了apache的扩展包，可以用于解析php，我觉得不管是7版本还是5版本都可以适用。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个学习Python的小游戏]]></title>
    <url>%2F2017%2F04%2F21%2F%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%B9%A0Python%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[笔者最近在自学Python的过程中想起曾经有人推荐过的一款学习编程的小游戏，叫做Codecombat，通过玩游戏的方式学习编程语言的语法规则。 游戏有很多关卡，每个关卡都会有之前没有学过的语法，学习的难度是逐渐上升的，用游戏的方式将学习者带入比起看起枯燥的书本文字效果要好的多。 当然这里除了有Python之外还有Javascript等脚本语言可以学习。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL进阶]]></title>
    <url>%2F2017%2F04%2F17%2FSQL%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[我们都知道select的基本用法select &lt;字段名&gt; from &lt;表名&gt; [where &lt;限制条件&gt;]，然而select语句后面还可以跟很多限制条件。我们这次用user表来作为示范，下面是user表的结构： Between、And、In、&lt;=、&gt;=、&lt;、&gt;等条件查询：通过select * from table where id between 1 and 3和select * from table where id &gt;=1 and id &lt;= 3的返回结果，我们可以发现between and和&gt;= and &lt;=是等同的。如果我们要查询的条件不是一个连续的数值，可以用in：1select * from table where id in (2,4) locate()函数：locate(substr,str)这个函数返回substr在字符串str中的第一个出现的位置，如果不存在则值为0 Count()函数: count(字段名)：返回指定列的值的数目，但是字段值为NULL时不会被计算进去。select count(字段名) from &lt;表名&gt; count( )：返回表中的记录数，字段值为NULL时会被计算进去。`select count() from &lt;表名&gt;` Distinct语句：Distinct语句用于去除重复行，比如：select distinct * from &lt;表名&gt;。其他的语句或函数都可以和distinct配合使用，比如：count(distinct &lt;字段名&gt;)可以去除重复行统计行数，但是count(distinct *)是不被允许的 Union语句：Union语句可以将两个select语句的结果集组合成一个：1(select * from table where id &gt;= 3) union (select * from table where id = 1) 当我们使用union语句的时候，默认去除了重复行，和distinct的效果一样，如果要显示所有的结果，则要使用union all语句。 Drder by语句：1select * from table order by &lt;字段名&gt; [asc/desc] 其中asc是默认的排序，为升序，desc为降序。当然order by后面可以跟很多个字段，如：select * from table order by info desc,id asc,这个语句意为先按info字段降序，若info字段值相同的情况下，再按id字段升序。而且，NULL默认为值最小。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dict和Set]]></title>
    <url>%2F2017%2F04%2F12%2FDict%E5%92%8CSet%2F</url>
    <content type="text"><![CDATA[DictPython内置了字典Dict（全称Dictionary），使用键-值（key-value）存储，具有极快的查找速度。Dict的查找原理和查字典类似，key就相当于字典的索引，Python可以通过key计算出所对应的value存放的内存地址，直接取出，所以查找速度快。Dict的初始化很简单，语法如下： 123&gt;&gt;&gt; dict = &#123;key1' : value1, 'key2' = value2, 'key3' = value3&#125;&gt;&gt;&gt; dict['key2']value2 一个key只能对应一个value，所以当我们对一个key多次赋值时会将前一个value覆盖掉。由于需要查找的key不存在时，dict会报错，为了避免key不存在的情况，Python提供了两种方法： 通过in判断，如果key存在，就返回True，反之返回False： 1&gt;&gt;&gt; `key` in dict 通过get判断，如果key不存在就返回None（返回None的时候交互式命令行不显示结果），也可以是自己指定返回的内容： 12&gt;&gt;&gt; dict.get('key') #返回None&gt;&gt;&gt; dict.get('key',-1) #返回自己指定的值`-1` 删除Dict可以使用dict.pop(key)方法，对应的value也会从dict中删除。Dict内部的存放顺序和key的放入没有关系，Dict的查找和插入速度不会随着key的增加而变慢，需要占用大量的内存，是一种用空间来换取时间的方法。 SetSet和Dict类似，也是一组key的集合，但是不存储value。由于key不能重复，所以在set中没有重复的key。要创建一个set需要提供一个list作为输入的集合：1&gt;&gt;&gt; s = set([1,2,3,4,5]) 重复的元素会被set自动过滤，可以通过add(key)方法向set添加元素，通过remove(key)方法删除元素。我们可以将set看作数学意义上的集合，因此，两个set之间可以做数学意义上的交(&amp;)、并(|)集等运算]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2017%2F04%2F07%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[最近在自学Python，所以一边学也一边总结一些知识点 Python的输出Python的输出和C语言类似，在print()函数里加上字符串（用单引号或者双引号，但是不能混用），例如：1&gt;&gt;&gt; print('Hello world!') print()函数也可以接受多个字符串，用逗号隔开即可。print()函数依次打印字符串，每遇到逗号就会输出一个空格。print()也可以打印整数或者计算结果，例如：1&gt;&gt;&gt; print('5+3=',5+3) 注：对于5+3，python解释器会自动计算出结果，但是&#39;5+3=&#39;是字符串而非数学公式 Python的输入Pyhton提供了input()函数，可以让用户输入字符串，并且存到一个变量里，例如：1&gt;&gt;&gt; info = input() 输入任意字符后按下回车完成输入，输入的内容就被存放在变量info里面了。input()函数可以显示一个字符串来提示用户，如：input(&#39;please input something:&#39;) Python的数据类型 整数：Python可以处理任意大小的整数，包括负整数。 浮点数：与C语言一样，可以用数学法也可以用科学记数法（把10用e替代）表示。 字符串：字符串使用单引号或者双引号括起来的任意文本；如果文本中包含&#39;和&quot;可以用转义字符\来表示。 布尔值：一个布尔值只有True和False两种值（注意大小写）；布尔值可以用and（与运算）、or（或运算）和not（非运算）运算。 空值：空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的整数，而None是一个特殊的空值；类似于C语言里面的NULL。 变量：和C语言类似，变量名必须是大小写英文、数字和下划线的组合，且不能用数字开头；如：1a = 123 这种变量本身类型不固定的语言称为动态语言，与之对应的是静态语言。静态语言在定义变量是必须指定变量类型，如：1int a = 123 和静态语言相比，动态语言更灵活。 常量：所谓常量就是不能变的变量，在Python中，通常用全部大写的变量名表示常量。 Python的整数除法和取余 /：这种整数的除法得到的结果是浮点数，即使两个整数恰好整除结果也是浮点数。 //：这种除法也称为地板除，两个整数的相除结果仍然为整数，和C语言中的整数除法一样，整数除法结果为小数时取整数部分。 %：与C语言的取余一样，结果为两整数相除的余数。 Python的listlist类似于数组的概念，可以随时添加和删除元素；与数组一样，list[]的索引是从0开始的，但是访问元素时要确保索引不要越界，可以用len()函数来获取元素的个数，如：1&gt;&gt;&gt; len(list) #变量list是一个list 所以最后一个元素的索引是len(list)-1，当然也可以用-1来做索引，直接获取最后一个元素list[-1]，以此类推可以用-2、-3来获取倒数第二个的、倒数第三个元素。 Python提供lsit.insert()函数将元素插入到特定的位置，如：1&gt;&gt;&gt; list.insert(x,'info')#x为想插入元素位置的索引号，info为想插入的 元素 也可以用list.addend()函数将元素插入到末尾，如：1&gt;&gt;&gt; list.addend('info') #info为想插入的元素 想要删除list末尾元素用list.pop()函数，想要删除指定位置的元素，用list.pop(x)方法，其中x是索引位置。list可以直接赋值，而且list中的元素类型也可以不同。 Python的tuple这是Python的另一个有序列表，叫做元组（tuple）。tuple和list类似，但是tuple一旦初始化就不能进行修改了；我们依然可以使用tuple[0]、tuple[-1]来获取元素。由于tuple不可变，所以相比list更加安全，所以能用tuple就尽量使用tuple。下面说一下tuple的定义：12&gt;&gt;&gt; tuple = (1,2,3,4) #正常的tuple定义&gt;&gt;&gt; tuple = () #定义空的tuple 但是当定义一个元素的tuple的时候，如果写成这样：1&gt;&gt;&gt; tuple = (1) 由于小括号()既可以表示tuple又可以表示数学公式中的小括号，就产生了歧义。因此，Python规定这种情况下()按照数学公式的小括号计算，结果即为1，所以，只有一个元素的tuple定义是要加一个逗号,来消除歧义：1&gt;&gt;&gt; tuple = (1,) 当然了，tuple的元素中如果包含一个list的话，list的元素是可以改变的 Python的条件判断和C语言类似，Python的条件判断的语法如下：123456789if &lt;判断条件1&gt;: &lt;执行代码&gt;elif &lt;判断条件2&gt;: &lt;执行代码&gt;elif &lt;判断条件3&gt;: &lt;执行代码&gt; …………else: &lt;执行代码&gt; 我们可以通过使用之前说过的input()函数的输入进行条件判断，但是有一个需要注意的地方，input()函数返回的数据类型是str，不能直接和整数比较，所以必须要先使用int()函数将str转换为整数。 Python的循环for……in:这个循环可以将list或tuple中的元素遍历出来，看个例子：123num = ['1','2','3','4']for x in num: print(x) 执行这段代码，会依次打印每一个元素，所以for x in ……就是把每个元素带入变量x，然后执行缩进块的语句。有了这个循环我们就可以做求和了，不过我们要从1写到100确实有点困难，幸好Python提供了range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。如：12&gt;&gt;&gt; list(range(5))[0,1,2,3,4] #range(5)生成的是从0开始小于5的整数 while:和C语言类似，条件满足就循环，条件不满足时就退出循环。语法如下：12while &lt;判断条件&gt;&lt;执行语句&gt; break和continue:和C语言类似，break可以提前退出循环，continue可以跳过当前循环，直接进入下一次循环。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL语句的基本操作]]></title>
    <url>%2F2017%2F04%2F04%2FSQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据库操作 创建数据库： CREATE DATABASE &lt;数据库名&gt; [其他选项] 使用数据库： USE &lt;数据库名&gt; 修改数据库： ALTER DATABASE &lt;数据库名&gt; 删除数据库： DROP DATABASE &lt;数据库名&gt; 数据表操作 创建表： 12345678910111213CREATE TABLE &lt;表名&gt;（ &lt;列名1&gt;&lt;数据类型&gt;[&lt;列级完整性约束&gt;], [&lt;列名n&gt;&lt;数据类型&gt;[&lt;列级完整性约束&gt;]] ）;例： create table studets ( id int not null auto_increment primary key, name varchar(8) not null, sex varchar(5) not null, score int(5) not null ) 修改基本表 12345ALTER TABLE &lt;表名&gt; add &lt;列名&gt; &lt;列数据类型&gt; [after 插入位置]; --增加列ALTER TABLE &lt;表名&gt; change &lt;列名&gt; &lt;列新名&gt; &lt;新数据类型&gt;; --修改列ALTER TABLE &lt;表名&gt; drop &lt;列名&gt;; --删除列ALTER TABLE &lt;表名&gt; rename &lt;新表名&gt;; --重命名表DROP TABLE &lt;表名&gt; --删除表 表的基本操作 插入数据：insert [into] &lt;表名&gt; [(列名1,列名2,列名3……)] values (值1,值2,值3……); 更新数据：update &lt;表名&gt; set 列名=新值 where 更新条件; 删除数据：delete from &lt;表名&gt; where 删除条件; 查询数据：select &lt;列名&gt; from &lt;表名&gt; [查询条件]; 特定条件查询：where不仅支持“where列名=值”这种名等于值的查询形式，对一般的比较运算的运算符都是支持的，如=、&lt;、&gt;、！=等以及一些扩展运算符is[not] null、in、like等，还可以对查询条件使用or和and进行组合查询。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于TCP]]></title>
    <url>%2F2017%2F04%2F04%2F%E5%85%B3%E4%BA%8ETCP%2F</url>
    <content type="text"><![CDATA[互联网协议族（Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP协议集。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（TCP/IP Protocol Stack） 以上来自维基百科，我们知道TCP/IP协议族是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大的集合。其中包含了ARP、UDP、ICMP（互联网消息控制管理协议）等协议，它将软件的通信过程抽象化为四个抽象层（应用层、传输层、网络层和物理层），类似于简化的OSI七层。 在数据传输方面，早期研发提出两种传输方式——面向连接的传输和非面向连接的传输，经过后来长期的发展，提出面向连接的ISO组织将非面向连接的传输纳入自己麾下，就是现在的UDP。 TCPTCP建立连接的过程——TCP的三次握手首先，源向目的发送一个TCP同步请求（syn包）；目的收到后向源发一个TCP回应（offer包），这里面包含了syn+ack信息，此时处于半打开会话状态，存在巨大的安全隐患；源收到目的的回应后向目的发送一个TCP确认包（ack包），就此处于全打开会话状态，TCP连接建立完成。 TCP序列号和确认号TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收（发送序列号是当前的发包情况，确认号是渴望的发包情况）。 例如在握手的时候，源向目的发送syn包，seq=x；目的会给源一个回应，seq=y，ack=x+1；源收到了之后给目的回一个确认包，ack=y+1。 TCP划窗TCP协议通过划窗机制来对流量进行控制管理，接收端通过发送确认号告诉发送端自己获包的情况，接收端通过三次发包后了解接收端的网络吞吐能力，然后稳定发包。 TCP重传TCP包超时未响应后进行重传，一个包最多重传16次，无法处理后连接断开重连，三次失败后无法进行连接 以上均为自己极浅的理解，详细内容还请移步至Google]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决配置完七牛后无法Deploy到gihub]]></title>
    <url>%2F2017%2F02%2F14%2F%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E5%AE%8C%E4%B8%83%E7%89%9B%E5%90%8E%E6%97%A0%E6%B3%95Deploy%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[将七牛的插件配置好后我写了上一篇博客试一试效果，结果发现怎么也没部署到github，每次hexo d都会出现1ERROR Deployer not found: git 这样的报错，Google了半天都没有找到解决的办法，最后在找到了github上的一条issue，终于发现了解决办法：只要将配置文件_config.yml中plugins的那段给注释掉就OK了，即12#plugins:#- hexo-qiniu-sync 还是希望开发者能早点修改文档吧，不然还真的挺容易出事，不过说一句，我的Hexo是3.2.2的版本的，不知道2.x版本会不会出现类似的情况]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭配七牛存储图片等媒体资源]]></title>
    <url>%2F2017%2F02%2F14%2FHexo%E6%90%AD%E9%85%8D%E4%B8%83%E7%89%9B%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E7%AD%89%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[今天把博客的图片存储搞了一下，利用的七牛存储，相对来说还是比较简单，但是为了测试成功与否就只好写这篇博客了。七牛 是一个云存储服务商，注册并实名认证之后后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。如果想要注册可以点击这里，这样可以为我增加每月5GB的容量。注册完成之后就可以进行创建空间了，注意我们添加的资源为对象存储，访问控制为公开空间 然后点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到下面我们会用到一个叫做的hexo-qiniu-sync的插件，首先在hexo主目录下安装：1npm install hexo-qiniu-sync - -save 然后把配置信息添加到_config.yml中12345678910111213141516171819202122232425262728293031323334353637plugins: - hexo-qiniu-sync#七牛云存储设置##offline 是否离线. 离线状态将使用本地地址渲染##sync 是否同步##bucket 空间名称.##access_key 上传密钥AccessKey##secret_key 上传密钥SecretKey##secret_file 秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可##dirPrefix 上传的资源子目录前缀.如设置，需与urlPrefix同步 ##urlPrefix 外链前缀.##up_host 上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com##local_dir 本地目录.##update_exist 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)##image/js/css 子参数folder为不同静态资源种类的目录名称，一般不需要改动##image.extend 这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ ## 可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图qiniu: offline: false sync: true bucket: bucket_name secret_file: sec/qn.json or C: access_key: AccessKey secret_key: SecretKey dirPrefix: static urlPrefix: http://bucket_name.qiniudn.com/static up_host: http://upload.qiniu.com local_dir: static update_exist: true image: folder: images extend: js: folder: js css: folder: css 其中各个参数在插件的README文件中都有详细的介绍，按照github上的教程一步一步来是很简单的。 然后在hexo主目录下创建本地目录（该目录要和配置中local_dir参数保持一致），然后创建iamges、js、css子目录，这样基本的配置就完成了 下面就可以在你的文章中试着插入图片了，比如你想引用在你/local_dir/images/下的图片1.png1&#123;% qnimg 1.png %&#125; 更高级的用法请参考github上的说明。 下面进行同步1hexo qiniu s]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu系统设置打不开]]></title>
    <url>%2F2017%2F02%2F14%2F%E8%A7%A3%E5%86%B3Ubuntu%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E6%89%93%E4%B8%8D%E5%BC%80%2F</url>
    <content type="text"><![CDATA[今天把Ubuntu从16.04更新到16.10之后卸载了些软件，之后蛋疼的发现系统设置打不开了，真是欲哭无泪。去网上搜了下发现是我之前由于卸载了iBus导致的，虽然我不懂为什么iBus和Ubuntu之间的关系为什么会如此紧密，但是既然发生了这种事情我也很绝望啊，只能按照网上的方法1sudo apt-get install ubuntu-desktop #这个会把Ubuntu预装的软件office还有Amazon什么的装回来，装完自己再慢慢卸载吧 或者他也提供了一次性的安装办法1sudo apt-get install ibus-pinyin unity-control-center unity-control-center-signon webaccounts-extension-common xul-ext-webaccounts 但是我眉头一皱，发现事情并不简单，我继续搜了下去，也有很多人遇到这种问题，发现还有更简单的办法12sudo apt-get install gnome-control-center #如果系统设置打不开，请重新安装gnome-control-centersudo apt-get install unity-control-center #如果设置里只有很少的几个图标请重新安装unity-control-center 当然上面两个方法并没有尝试过，我也无从得知导致我系统设置打不开的原因是不是卸载了iBus]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo的建站之旅]]></title>
    <url>%2F2017%2F02%2F14%2FHexo%E7%9A%84%E5%BB%BA%E7%AB%99%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[这几天觉得wordpress作为博客实在是太臃肿了，而且访问的后台以及更新都极其的慢，以至于想把博客迁到Hexo上去。Hexo 是个简洁快速且高效的博客框架，是个台湾的学生写的，所以对中文还是挺友好的，我们用起来也很方便，而且Hexo仅依赖node，易于安装。首先准备的工具仅需要node.js,git即可，在ubuntu上安装这两样工具也是极其简单：1234sudo apt-get install nodejssudo apt-get install npm sudo apt-get install nodejs-legacy #由于ubuntu仓库中本来就有一个node，所以在ubuntu下nodejs命令不是node而是nodejs，但是安装nodejs-legacy后就可以解决这个问题了，具体为什么我也不知道sudo apt-get install git 下面开始安装Hexo:1sudo npm install -g hexo-cli 安装完成后就可以部署博客了，根据Hexo官网上的步骤：123hexo init &lt;floder&gt;cd &lt;floder&gt;sudo nmp install #安装依赖包 下面可以安装一些插件，大家可以根据不同的需要安装，网上都有教程，我就不赘述了，但是有一个插件是需要安装的：1npm install hexo-deployer-git --save #这是一个可以自动部署到github上的插件 接下来的配置可以参考官网上给出的配置详解，自己根据需要去手动配置，至于主题可以在Hexo提供的网站选择，然后从github上clone到themes下。配置完成后可以执行一下命令：12hexo cleanhexo generate #这个命令用于部署网页的静态文件，每次修改后都应该首先执行这条命令 如果想先预览网页效果的话，可以执行：1hexo s #s即server,执行完成后可以在localhost:4000下预览 下面需要部署github端了，首先在你的github上创建一个仓库，仓库名必须为”username.github.io”，其中”username”为你的用户名，创建完成后写一个README使github自动帮你创建github pages 接着在你的终端配置git:12git config --global user.name "你github的username"git config --global user.email "你的github邮箱" 然后生成密钥：1ssh-keygen -t rsa -C "你的邮箱" 回车确认，输入密码再确认，然后前往提示信息的目录下会有两个文件，其中id_rsa是私钥，id_rsa.pub是公钥然后添加生成的key：1ssh-add id_rsa 然后将id_rsa.pub中的内容（除去最后你邮箱的那部分）复制下来，在你github主页中找到settings中的SSH Keys，将复制的公钥添加进去，title随便取个名字就好。最后我们只要把Hexo生产的网页部署到github上就可以了，来到我们创建的博客目录，打开配置文件，在Deployment中配置：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/username/username.github.io branch: master 同样的，”username”是你github的用户名然后在博客根目录执行：12hexo generate hexo deploy #部署博客到github 输出一下信息便说明我们部署成功：1INFO Deploy done:git]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次Arch的安装经历]]></title>
    <url>%2F2017%2F02%2F13%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Arch%E7%9A%84%E5%AE%89%E8%A3%85%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[最近由于听信了别人的“谗言”，心血来潮想试一试Arch，所以便准备在虚拟机上装一个Arch来看看效果，也算是一次艰难的装系统之路了吧。 那么下面打开虚拟机，进入安装界面： 首先是分区，Arch给我们提供了一个很好的分区交互工具cfdisk1cfdisk #使用cfdisk进行分区 选择第二个dos类型，这是将sda设置成MBR类型的分区，之前在遇到这个选项的时候，我下意识的选了第一个GPT，然后还去google了一下，说GPT很好,就使用这个吧，结果后面分区的时候和教程不一样，装好系统后怎么也进不去。 接下来你可以把整个硬盘设置成一个根分区或者分成一个根分区和一个boot分区。如果设置成一个根分区记得要把那个分区设置bootable；如果是一个根分区和一个boot分区记得要把boot分区设置bootable。 退出cfdisk后格式化新设置的分区123lsblk #查看存储设备的状态，sda1、sda2这样的就是我们刚刚分出来的mkfs.ext4 /dev/sda1mkfs.ext4 /dev/sda2 #将根分区和boot分区格式化成ext4格式 然后就可以进行挂载了123mount /dev/sda2 /mnt #将根分区挂载到/mntmkdir /mnt/boot #为boot分区创建挂载点mount /dev/sda1 /mnt/boot 接着修改软件镜像源123456cd /etc/pacman.d #镜像源文件在这个目录下#我们需要将China源放到文件头的位置，下面先将这段源提取到temp这个文件里grep -A 1 '##.*China' mirrorlist|grep -v '\-\-' &gt; temp#然后将mirrorlist的内容添加到temp的最后面cat mirrorlist &gt;&gt; tempmv temp mirrorlist #temp替换mirrorlist 然后刷新软件仓库列表就可以开始安装了12pacman -Syy #刷新软件仓库列表pacstrap -i /mnt base base-devel #安装系统 接下来需要生成一个叫fstab的配置文件，在开机时候会由mount命令读取并挂载其中的分区。在安装完基本系统之后，就可以将fstab信息写入新安装的系统中了。12genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstabnano /mnt/etc/fstab #确认fstab文件真的生成了 下面我们就可以进入新系统进行配置了123arch-chroot /mnt /bin/bashpasswd #设置root密码echo 主机名 &gt; /etc/hostname #设置主机名 然后配置区域1nano /etc/locale.gen 将en_US.UTF-8、zh_CN.UTF-8、zh_TW.UTF-8的注释去掉，然后按Ctrl+x保存，退出，使用1locale-gen 生成区域，然后设置locale.conf文件1echo LANG=en_us.UTF-8 &gt; /etc/locale.conf#如果在终端下使用中会出现乱码，可以装fbterm来解决 下面配置时区1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 安装引导工具Grub123pacman -S grubgrub-install --recheck /dev/sda1 #将grub写入系统，没有提示错误说明写入成功grub-mkconfig -o /boot/grub/grub.cfg #生成配置文件 配置一下网络1systemctl enable dhcpcd.service 到现在为止，系统基本上配置好了，现在退出新系统，卸载挂载的分区，然后重启虚拟机123exitumount -R /mntreboot 剩下来的安装图形化界面和美化的步骤可以自行google。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs的安装]]></title>
    <url>%2F2017%2F02%2F09%2Fsqli-labs%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[笔者前段时间安装了sqli-labs，就想把sqli-labs和lamp环境的搭建都写出来，其实这两个东西都很简单，感觉比我折腾hexo要简单的得多了（手动滑稽）。 sqli 即 sql injection(sql注入)，sqli-labs是一个印度程序员写的用来学习sql注入的游戏教程，Youtube上有一套视频教程(需要科学上网)，github上也有开源的项目。 那么接下来就可以进行安装了：首先搭建lamp环境,我用的是ubuntu 16.04的系统 1.安装apache21sudo apt-get install apache2 2.安装mysql1sudo apt-get install mysql-server 3.安装php7(ubuntu16.04开始支持php7.0，之前的版本可以只支持到php5)12sudo apt-get install php7.0php7.0 -v #查看版本信息，确认安装成功 4.整合php与mysql1sudo apt-get install php7.0-mysql 5.重启apache和mysql服务12sudo service apache2 restartsudo service mysql restart 此时在浏览器输入localhost,便能显示apache的页面，也代表lamp环境到目前为止算是成功搭建完毕。 下面开始安装sqli-labs先从github上克隆sqli-labs代码：1git clone https://github.com/Audi-1/sqli-labs.git 然后修改sqli-labs数据库配置文件：12345678910vim sqli-labs/sql-connections/db-creds.inc #编辑配置文件修改如下：&lt;?php//give your mysql connection username n password$dbuser ='root';$dbpass ='你数据库密码';$dbname ="security";$host = 'localhost';$dbname1 = "challenges";?&gt; 然后将目录复制到apache的web目录：1sudo cp -r sqli-labs /var/www/html#默认是/var/www/html这个目录，也可以在apache的配置文件中修改目录 然后在浏览器中访问 http://127.0.0.1/sqli-labs或者http://localhost/sqli-labs 就能看到启动页面，点击页面中的Setup/reset Database for labs链接，让其进行安装。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于timestamp自动更新]]></title>
    <url>%2F2017%2F02%2F09%2F%E5%85%B3%E4%BA%8Etimestamp%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[最近笔者在“温习TP框架”（其实就是不会然后抓紧时间啃），从最简单Blog开始做起，以前学习的时候是跟着教程，用time()函数获取当前时间戳，然后用int型数据来存储。这一次我突然想用Mysql内置的时间类型的数据——timestamp。 Mysql中常用到的除了timestamp之外还有datetime，我们先来比较一下这两个的区别： timestamp占用的存储空间为4个字节，所以它能表示的时间范围为1970.1.1 08:00:01~2038.01.19 11:14:07，这个范围比较小，容易出现超出的情况。 datetime占用的存储空间为8个字节，所以它能表示的时间范围为1000.01.01 00:00:00~9999.12.31 23:59:59,这个时间范围完全够用了。 其实timestamp这个时间范围目前也是够用的，而且我也只是来学习的，所以我就选择了这个数据类型。然而后来我发现我在修改表中数据的时候时间并没有自动更新，这就比较奇怪了，我当时的sql代码是这样的：1date timestamp not null default current_timestamp; 后来一顿google发现了问题所在，如果这个数据属性没有加上default current_timestamp的话，就会默认创建数据时获取当前时间且数据更新时更新时间，然而加上了default current_timestamp则必须要再加上on update current_timestamp才能自动更新时间。总结如下： 如果该列属性default current_timestamp 和 on update语句都有，则初始值为当前时间并自动更新 如果该列属性default current_timestamp 和 on update语句都没有，则默认初始值为当前时间并自动更新 如果该列属性只有default current_timestamp，那么初始值当前时间且时间不会自动更新 如果该列属性只有on update语句，则初始值为0，会自动更新时间]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[琐事——换回Apache]]></title>
    <url>%2F2017%2F01%2F15%2F%E7%90%90%E4%BA%8B%E2%80%94%E2%80%94%E6%8D%A2%E5%9B%9EApache%2F</url>
    <content type="text"><![CDATA[由于之前在ubuntu上使用nginx总是会出现各种各样的问题，所以打算将自己机器上的nginx换成Apache，服务器上继续使用nginx，下面开始干活儿：首先将nginx完全卸载（包括配置文件)1sudo apt-get purge nginx 然后卸载不再需要nginx的依赖程序1sudo apt-get autoremove 卸载完成后就可以开始安装Apache 了1sudo apt-get install apache2 然后查看Apache的版本信息，确认安装完成123apache2 -vServer version: Apache/2.4.18 (Ubuntu)Server built: 2016-07-14T12:32:26 这个时候在浏览器里访问localhost就会出现一个Apache2 Ubuntu Default Page的页面，说明Apache已经可以正常工作了。下面在安装一个依赖包让Apache2可以解析php代码1sudo apt-get install libapache2-mod-php7.0 做到这里基本上就已经结束了，然后剩下的apache就不在多说了，文件就在etc/apache2/下。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
